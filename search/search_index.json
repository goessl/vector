{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"vector","text":"<p>An infinite-dimensional vector Python package. <pre><code>&gt;&gt;&gt; from vector import vecadd\n&gt;&gt;&gt; vecadd((1, 2), (4, 5, 6))\n(5, 7, 6)\n&gt;&gt;&gt; \n&gt;&gt;&gt; from vector import Vector\n&gt;&gt;&gt; v = Vector((1, 2))\n&gt;&gt;&gt; w = Vector((4, 5, 6))\n&gt;&gt;&gt; v + w\nVector(5, 7, 6, ...)\n&gt;&gt;&gt; \n&gt;&gt;&gt; from vector import vecnpadd\n&gt;&gt;&gt; vecnpadd((1, 2), ((3, 4, 5),\n...                   (6, 7, 8)))\narray([[4, 6, 5],\n       [7, 9, 8]])\n</code></pre></p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/goessl/vector.git\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>This package includes</p> <ul> <li>general-purpose functions (prefixed <code>vec...</code>) in pure Python with perfect complexity,</li> <li>lazy generators (prefixed <code>vecl...</code>),</li> <li>in-place modifications (prefixed <code>veci...</code>),</li> <li><code>dicts</code> as sparse vectors (prefixed <code>vecs...</code>),</li> <li>tensor functions (prefixed <code>ten...</code>) for multilinear operations,</li> <li>sparse tensor functions (prefixed <code>tens...</code>) for multilinear sparse operations &amp;</li> <li>improved numpy-routines (prefixed <code>vecnp...</code>) for parallelised operations.</li> </ul> <p>Functional, sparse and multilinear sparse additionally contain wrapper classes.</p> <p>to handle type-independent, infinite-dimensional vectors. It operates on vectors of different lengths, treating them as infinite-dimensional by assuming that all components after the given ones are zero.</p> <p>All vectors are zero-indexed.</p> Operation Functional Lazy In-place Sparse Multilinear Multilinear sparse Parallelised Creation Zero constant <code>veczero</code> <code>veclzero</code> <code>vecizero</code> <code>vecszero</code> <code>tenzero</code> <code>tenszero</code> <code>vecnpzero</code> Basis <code>vecbasis</code> <code>veclbasis</code> <code>vecibasis</code> <code>vecsbasis</code> <code>tenbasis</code> <code>tensbasis</code> <code>vecnpbasis</code> Bases <code>vecbases</code> <code>veclbases</code> <code>vecibases</code> <code>vecsbases</code> Random uniform <code>vecrand</code> <code>veclrand</code> <code>vecirand</code> <code>vecsrand</code> <code>tenrand</code> <code>tensrand</code> <code>vecnprand</code> Random normal <code>vecrandn</code> <code>veclrandn</code> <code>vecirandn</code> <code>vecsrandn</code> <code>tenrandn</code> <code>tensrandn</code> <code>vecnprandn</code> Conversion to special type <code>vecdtos</code> from special type <code>vecstod</code> Utility Dimensionality <code>veclen</code> <code>tendim</code> <code>tensdim</code> <code>vecnpdim</code> Rank <code>vecslen</code> <code>tenrank</code> <code>tensrank</code> Comparison <code>veceq</code> <code>vecleq</code> <code>vecseq</code> <code>tenseq</code> <code>vecnpeq</code> Trimming <code>vectrim</code> <code>vecltrim</code> <code>vecstrim</code> <code>tentrim</code> <code>tenstrim</code> <code>vecnptrim</code> in-place <code>vecitrim</code> <code>vecsitrim</code> <code>tensitrim</code> Right shift <code>vecrshift</code> <code>veclrshift</code> <code>vecsrshift</code> <code>tenrshift</code> <code>tensrshift</code> in-place <code>vecirshift</code> <code>vecsirshift</code> Left shift <code>veclshift</code> <code>vecllshift</code> <code>vecslshift</code> <code>tenlshift</code> <code>tenslshift</code> in-place <code>vecilshift</code> <code>vecsilshift</code> Hilbert space Conjugation <code>vecconj</code> <code>veclconj</code> <code>vecsconj</code> <code>tenconj</code> <code>tensconj</code> in-place <code>veciconj</code> <code>vecsiconj</code> <code>tensiconj</code> Norm <code>vecabs</code> <code>vecsabs</code> <code>vecnpabs</code> Norm squared <code>vecabsq</code> <code>vecsabsq</code> <code>vecnpabsq</code> Inner product <code>vecdot</code> <code>vecsdot</code> <code>vecnpdot</code> Parallelism <code>vecparallel</code> <code>vecsparallel</code> <code>vecnpparallel</code> Vector space Positive <code>vecpos</code> <code>veclpos</code> <code>vecspos</code> <code>tenpos</code> <code>tenspos</code> <code>vecnppos</code> in-place <code>vecipos</code> <code>vecsipos</code> <code>tensipos</code> Negative <code>vecneg</code> <code>veclneg</code> <code>vecsneg</code> <code>tenneg</code> <code>tensneg</code> <code>vecnpneg</code> in-place <code>vecineg</code> <code>vecsineg</code> <code>tensineg</code> Addition <code>vecadd</code> <code>vecladd</code> <code>vecsadd</code> <code>tenadd</code> <code>tensadd</code> <code>vecnpadd</code> in-place <code>veciadd</code> <code>vecsiadd</code> <code>tensiadd</code> Basis addition <code>vecaddc</code> <code>vecladdc</code> <code>vecsaddc</code> <code>tenaddc</code> <code>tensaddc</code> in-place <code>veciaddc</code> <code>vecsiaddc</code> <code>tensiaddc</code> Subtraction <code>vecsub</code> <code>veclsub</code> <code>vecssub</code> <code>tensub</code> <code>tenssub</code> <code>vecnpsub</code> in-place <code>vecisub</code> <code>vecsisub</code> <code>tensisub</code> Basis subtraction <code>vecsubc</code> <code>veclsubc</code> <code>vecssubc</code> <code>tensubc</code> <code>tenssubc</code> in-place <code>vecisubc</code> <code>vecsisubc</code> <code>tensisubc</code> Multiplication <code>vecrmul</code> <code>veclrmul</code> <code>vecsrmul</code> <code>tenrmul</code> <code>tensrmul</code> from left <code>vecmul</code> <code>veclmul</code> <code>vecsmul</code> <code>tenmul</code> <code>tensmul</code> <code>vecnpmul</code> in-place <code>vecimul</code> <code>vecsimul</code> <code>tensimul</code> True division <code>vectruediv</code> <code>vecltruediv</code> <code>vecstruediv</code> <code>tentruediv</code> <code>tenstruediv</code> <code>vecnptruediv</code> in-place <code>vecitruediv</code> <code>vecsitruediv</code> <code>tensitruediv</code> Floor division <code>vecfloordiv</code> <code>veclfloordiv</code> <code>vecsfloordiv</code> <code>tenfloordiv</code> <code>tensfloordiv</code> <code>vecnpfloordiv</code> in-place <code>vecifloordiv</code> <code>vecsifloordiv</code> <code>tensifloordiv</code> Mod <code>vecmod</code> <code>veclmod</code> <code>vecstruediv</code> <code>tenmod</code> <code>tensmod</code> <code>vecnpmod</code> in-place <code>vecimod</code> <code>vecsitruediv</code> <code>tensimod</code> Divmod <code>vecdivmod</code> <code>vecldivmod</code> <code>vecsdivmod</code> <code>tendivmod</code> <code>tensdivmod</code> Elementwise Multiplication <code>vechadamard</code> <code>veclhadamard</code> <code>vecihadamard</code> <code>vecshadamard</code> <code>tenhadamard</code> <code>tenshadamard</code> True division <code>vechadamardtruediv</code> <code>veclhadamardtruediv</code> <code>vecihadamardtruediv</code> <code>vecshadamardtruediv</code> <code>tenhadamardtruediv</code> <code>tenshadamardtruediv</code> Floor division <code>vechadamardfloordiv</code> <code>veclhadamardfloordiv</code> <code>vecihadamardfloordiv</code> <code>vecshadamardfloordiv</code> <code>tenhadamardfloordiv</code> <code>tenshadamardfloordiv</code> Mod <code>vechadamardmod</code> <code>veclhadamardmod</code> <code>vecihadamardmod</code> <code>vecshadamardmod</code> <code>tenhadamardmod</code> <code>tenshadamardmod</code> Divmod <code>vechadamarddivmod</code> <code>veclhadamarddivmod</code> <code>vecshadamarddivmod</code> <code>tenhadamarddivmod</code> <code>tenshadamarddivmod</code> Min <code>vechadamardmin</code> <code>veclhadamardmin</code> <code>vecshadamardmin</code> <code>tenhadamardmin</code> <code>tenshadamardmin</code> Max <code>vechadamardmax</code> <code>veclhadamardmax</code> <code>vecshadamardmax</code> <code>tenhadamardmax</code> <code>tenshadamardmax</code>"},{"location":"#design-choices","title":"Design choices","text":"<ol> <li>Integers are the best.    As many functions as possible should work with pure integer arithmetic.</li> <li>Floats are necessary. (Also let's don't forget about complex numbers.)    When possible, extended precision intermediates are used (<code>sum</code>, <code>sumprod</code>, ...)</li> <li>Python allows operator overloading.    Exclusive type arithmetic should be possible (<code>zero</code>, <code>one</code> &amp; <code>inf</code> arguments; ...)</li> </ol>"},{"location":"#prefix-design","title":"Prefix Design","text":"<p>Could use no prefix to be more mathematically pure, like <code>add</code> instead of <code>vecadd</code>, but then you would always have to use <code>from vec import add as vecadd</code> if used with other libraries (like <code>operator</code>).</p> <p>Also avoids keyword collisions (<code>abs</code> is reserved, <code>vecabs</code> isn't).</p> <p>Do it like <code>numpy.polynomial.polynomial. ...</code>.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> <code>zip</code> version between <code>zip</code> &amp; <code>zip_longest</code>. Yields different sized tuples. Done: goessl/zipvar</li> <li> <code>vecdivmod</code></li> <li> docstrings</li> <li> <code>numpy</code> routines</li> <li> multilinear vectors: tensors?</li> <li> Absolute type safety.</li> <li> Complexity analysis. Perfect complexity</li> <li> dimensionality signature (e.g. <code>vecadd</code>: \\(\\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^{\\max{m, n}}\\))</li> <li> sparse vectors (<code>dict</code>s)</li> <li> in-place</li> <li> argument checks</li> <li> lp-norms &amp; metrics</li> <li> <code>vechadamardminmax</code></li> <li> never use <code>numpy.int64</code>, they don't detect overflows</li> <li> C++ &amp; Java version</li> <li> Ballin</li> <li> Fields medal</li> </ul>"},{"location":"#license-mit","title":"License (MIT)","text":"<p>Copyright (c) 2022-2025 Sebastian G\u00f6ssl</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"functional/","title":"Functional","text":"<p>Vector operation functions.</p> <pre><code>&gt;&gt;&gt; from vector import vecadd\n&gt;&gt;&gt; a = (5, 6, 7)\n&gt;&gt;&gt; b = [2]\n&gt;&gt;&gt; c = range(4)\n&gt;&gt;&gt; vecadd(a, b, c)\n(7, 7, 9, 3)\n</code></pre> <p>Prefixed by <code>vec...</code> (vector).</p> <p>All functions accept vectors as single exhaustible iterables.</p> <p>They return vectors as tuples.</p> <p>The functions are type-independent. However, the coefficients used must support necessary scalar operations. For instance, for vector addition, coefficients must be addable.</p> <p>For complete type safety a zero argument is available. Default is <code>int(0)</code>.</p>"},{"location":"functional/#vector.functional--docstring-conventions","title":"Docstring conventions","text":"<p>Summary</p> <p>Math notation (vector notation if possible, index notation, domain &amp; codomain)</p> <p>More information (\"More efficient than ...\").</p> Complexity <p>For a vector of length \\(n\\) there will be - \\(x\\) scalar additions (<code>add</code>), ...</p> Notes <p>Design choices</p> See also <p>Similar functions</p> References <p>Wikipedia, numpy, ...</p>"},{"location":"functional/#vector.functional.creation","title":"<code>creation</code>","text":""},{"location":"functional/#vector.functional.creation.veczero","title":"<code>veczero = ()</code>","text":"<p>Zero vector.</p> \\[     \\vec{0} \\qquad \\mathbb{K}^0 \\] <p>An empty tuple: <code>()</code>.</p>"},{"location":"functional/#vector.functional.creation.vecbasis","title":"<code>vecbasis(i, c=1, zero=0)</code>","text":"<p>Return a basis vector.</p> \\[     c\\vec{e}_i \\qquad \\mathbb{K}^{i+1} \\] <p>Returns a tuple with <code>i</code> many <code>zero</code>s followed by <code>c</code>.</p> See also <ul> <li>for all basis vectors: <code>vecbases</code></li> </ul> Source code in <code>vector\\functional\\creation.py</code> <pre><code>def vecbasis(i, c=1, zero=0):\n    r\"\"\"Return a basis vector.\n\n    $$\n        c\\vec{e}_i \\qquad \\mathbb{K}^{i+1}\n    $$\n\n    Returns a tuple with `i` many `zero`s followed by `c`.\n\n    See also\n    --------\n    - for all basis vectors: [`vecbases`][vector.functional.creation.vecbases]\n    \"\"\"\n    return (zero,)*i + (c,)\n</code></pre>"},{"location":"functional/#vector.functional.creation.vecbases","title":"<code>vecbases(start=0, c=1, zero=0)</code>","text":"<p>Yield all basis vectors.</p> \\[     \\left(\\vec{e}_n\\right)_{n\\in\\mathbb{N}_{\\geq\\text{start}}} = \\left(\\vec{e}_\\text{start}, \\vec{e}_{\\text{start}+1}, \\dots \\right) \\] See also <ul> <li>for single basis vector: <code>vecbasis</code></li> </ul> Source code in <code>vector\\functional\\creation.py</code> <pre><code>def vecbases(start=0, c=1, zero=0):\n    r\"\"\"Yield all basis vectors.\n\n    $$\n        \\left(\\vec{e}_n\\right)_{n\\in\\mathbb{N}_{\\geq\\text{start}}} = \\left(\\vec{e}_\\text{start}, \\vec{e}_{\\text{start}+1}, \\dots \\right)\n    $$\n\n    See also\n    --------\n    - for single basis vector: [`vecbasis`][vector.functional.creation.vecbasis]\n    \"\"\"\n    for i in count(start=start):\n        yield vecbasis(i, c=c, zero=zero)\n</code></pre>"},{"location":"functional/#vector.functional.creation.vecrand","title":"<code>vecrand(n)</code>","text":"<p>Return a random vector of uniform sampled <code>float</code> coefficients.</p> \\[     \\vec{v}\\sim\\mathcal{U}^n([0, 1[) \\qquad \\mathbb{K}^n \\] <p>The coefficients are sampled from a uniform distribution in <code>[0, 1[</code>.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\functional\\creation.py</code> <pre><code>def vecrand(n):\n    r\"\"\"Return a random vector of uniform sampled `float` coefficients.\n\n    $$\n        \\vec{v}\\sim\\mathcal{U}^n([0, 1[) \\qquad \\mathbb{K}^n\n    $$\n\n    The coefficients are sampled from a uniform distribution in `[0, 1[`.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    return tuple(veclrand(n))\n</code></pre>"},{"location":"functional/#vector.functional.creation.vecrandn","title":"<code>vecrandn(n, normed=True, mu=0, sigma=1, weights=None)</code>","text":"<p>Return a random vector of normal sampled <code>float</code> coefficients.</p> \\[     \\vec{v}\\sim\\mathcal{N}^n(\\mu, \\sigma) \\qquad \\mathbb{K}^n \\] <p>The coefficients are sampled from a normal distribution.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\functional\\creation.py</code> <pre><code>def vecrandn(n, normed=True, mu=0, sigma=1, weights=None):\n    r\"\"\"Return a random vector of normal sampled `float` coefficients.\n\n    $$\n        \\vec{v}\\sim\\mathcal{N}^n(\\mu, \\sigma) \\qquad \\mathbb{K}^n\n    $$\n\n    The coefficients are sampled from a normal distribution.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    v = tuple(veclrandn(n, mu, sigma))\n    return vectruediv(v, vecabs(v, weights)) if normed else v\n</code></pre>"},{"location":"functional/#vector.functional.utility","title":"<code>utility</code>","text":""},{"location":"functional/#vector.functional.utility.veclen","title":"<code>veclen(v)</code>","text":"<p>Return the length (number of set coefficients).</p> <p>Doesn't handle trailing zeros, use <code>vectrim</code> if needed.</p> Notes <p>For generators as they have no <code>len</code>gth, altough the vector is gone then.</p> Source code in <code>vector\\functional\\utility.py</code> <pre><code>def veclen(v):\n    \"\"\"Return the length (number of set coefficients).\n\n    Doesn't handle trailing zeros, use [`vectrim`][vector.functional.utility.vectrim]\n    if needed.\n\n    Notes\n    -----\n    For generators as they have no `len`gth, altough the vector is gone then.\n    \"\"\"\n    return sum(1 for _ in v)\n</code></pre>"},{"location":"functional/#vector.functional.utility.veceq","title":"<code>veceq(v, w)</code>","text":"<p>Return whether two vectors are equal.</p> \\[     \\vec{v}\\overset{?}{=}\\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{B} \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be at most</p> <ul> <li>\\(\\min\\{n, m\\}\\) scalar comparisons (<code>eq</code>) &amp;</li> <li>\\(|n-m|\\) scalar boolean evaluations (<code>bool</code>).</li> </ul> Source code in <code>vector\\functional\\utility.py</code> <pre><code>def veceq(v, w):\n    r\"\"\"Return whether two vectors are equal.\n\n    $$\n        \\vec{v}\\overset{?}{=}\\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{B}\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be at most\n\n    - $\\min\\{n, m\\}$ scalar comparisons (`eq`) &amp;\n    - $|n-m|$ scalar boolean evaluations (`bool`).\n    \"\"\"\n    return all(vecleq(v, w))\n</code></pre>"},{"location":"functional/#vector.functional.utility.vectrim","title":"<code>vectrim(v, tol=None)</code>","text":"<p>Remove all trailing near zero (<code>abs(v_i)&lt;=tol</code>) coefficients.</p> \\[     \\begin{pmatrix}         v_0 \\\\         \\vdots \\\\         v_m     \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_j|&gt;\\text{tol}\\,\\}\\cup\\{-1\\} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\leq n} \\] <p><code>tol</code> may also be <code>None</code>, then all coefficients that evaluate to <code>False</code> are trimmed.</p> Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar absolute evaluations (<code>abs</code>) &amp;</li> <li>\\(n\\) scalar comparisons (<code>gt</code>).</li> </ul> Notes <ul> <li>Cutting of elements that are <code>abs(v_i)&lt;=tol</code> instead of <code>abs(v_i)&lt;tol</code> to allow cutting of elements that are exactly zero by <code>trim(v, 0)</code> instead of <code>trim(v, sys.float_info.min)</code>.</li> </ul> Source code in <code>vector\\functional\\utility.py</code> <pre><code>def vectrim(v, tol=None):\n    r\"\"\"Remove all trailing near zero (`abs(v_i)&lt;=tol`) coefficients.\n\n    $$\n        \\begin{pmatrix}\n            v_0 \\\\\n            \\vdots \\\\\n            v_m\n        \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_j|&gt;\\text{tol}\\,\\}\\cup\\{-1\\} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\leq n}\n    $$\n\n    `tol` may also be `None`,\n    then all coefficients that evaluate to `False` are trimmed.\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar absolute evaluations (`abs`) &amp;\n    - $n$ scalar comparisons (`gt`).\n\n    Notes\n    -----\n    - Cutting of elements that are `abs(v_i)&lt;=tol` instead of `abs(v_i)&lt;tol` to\n    allow cutting of elements that are exactly zero by `trim(v, 0)` instead\n    of `trim(v, sys.float_info.min)`.\n    \"\"\"\n    r, t = [], []\n    for x in v:\n        t.append(x)\n        if (x if tol is None else abs(x)&gt;tol):\n            r.extend(t)\n            t.clear()\n    return tuple(r)\n</code></pre>"},{"location":"functional/#vector.functional.utility.vecrshift","title":"<code>vecrshift(v, n, zero=0)</code>","text":"<p>Shift coefficients up.</p> \\[     (v_{i-n})_i \\qquad \\begin{pmatrix}         0 \\\\         \\vdots \\\\         0 \\\\         v_0 \\\\         v_1 \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n} \\] Source code in <code>vector\\functional\\utility.py</code> <pre><code>def vecrshift(v, n, zero=0):\n    r\"\"\"Shift coefficients up.\n\n    $$\n        (v_{i-n})_i \\qquad \\begin{pmatrix}\n            0 \\\\\n            \\vdots \\\\\n            0 \\\\\n            v_0 \\\\\n            v_1 \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n}\n    $$\n    \"\"\"\n    return tuple(veclrshift(v, n, zero=zero))\n</code></pre>"},{"location":"functional/#vector.functional.utility.veclshift","title":"<code>veclshift(v, n)</code>","text":"<p>Shift coefficients down.</p> \\[     (v_{i+n})_i \\qquad \\begin{pmatrix}         v_n \\\\         v_{n+1} \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}} \\] Source code in <code>vector\\functional\\utility.py</code> <pre><code>def veclshift(v, n):\n    r\"\"\"Shift coefficients down.\n\n    $$\n        (v_{i+n})_i \\qquad \\begin{pmatrix}\n            v_n \\\\\n            v_{n+1} \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}}\n    $$\n    \"\"\"\n    return tuple(vecllshift(v, n))\n</code></pre>"},{"location":"functional/#vector.functional.hilbert_space","title":"<code>hilbert_space</code>","text":""},{"location":"functional/#vector.functional.hilbert_space.vecconj","title":"<code>vecconj(v)</code>","text":"<p>Return the complex conjugate.</p> \\[     \\vec{v}^* \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n \\] <p>Tries to call a method <code>conjugate</code> on each element. If not found, simply keeps the element as is.</p> Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar conjugations (<code>conjugate</code>).</li> </ul> Source code in <code>vector\\functional\\hilbert_space.py</code> <pre><code>def vecconj(v):\n    r\"\"\"Return the complex conjugate.\n\n    $$\n        \\vec{v}^* \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n\n    Tries to call a method `conjugate` on each element.\n    If not found, simply keeps the element as is.\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar conjugations (`conjugate`).\n    \"\"\"\n    return tuple(veclconj(v))\n</code></pre>"},{"location":"functional/#vector.functional.hilbert_space.vecabs","title":"<code>vecabs(v, weights=None, conjugate=False, zero=0)</code>","text":"<p>Return the Euclidean/\\(\\ell_{\\mathbb{N}_0}^2\\)-norm.</p> \\[     ||\\vec{v}||_{\\ell_{\\mathbb{N}_0}^2}=\\sqrt{\\sum_iv_i^{(*)}v_i\\omega_i} \\qquad \\mathbb{K}^n\\to\\mathbb{K}_0^+ \\] <p>Returns the square root of <code>vecabsq</code>.</p> Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar conjugations (<code>conjugate</code>) (if selected),</li> <li>\\(n\\)/\\(2n\\) scalar multiplications (<code>mul</code>) without/with weights,</li> <li>\\(\\begin{cases}n-1&amp;n\\ge1\\\\0&amp;n\\le1\\end{cases}\\) scalar additions (<code>add</code>) &amp;</li> <li>one <code>^0.5</code> call.</li> </ul> See also <ul> <li>squared version without square root: <code>vecabsq</code></li> </ul> Source code in <code>vector\\functional\\hilbert_space.py</code> <pre><code>def vecabs(v, weights=None, conjugate=False, zero=0):\n    r\"\"\"Return the Euclidean/$\\ell_{\\mathbb{N}_0}^2$-norm.\n\n    $$\n        ||\\vec{v}||_{\\ell_{\\mathbb{N}_0}^2}=\\sqrt{\\sum_iv_i^{(*)}v_i\\omega_i} \\qquad \\mathbb{K}^n\\to\\mathbb{K}_0^+\n    $$\n\n    Returns the square root of [`vecabsq`][vector.functional.vecabsq].\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar conjugations (`conjugate`) (if selected),\n    - $n$/$2n$ scalar multiplications (`mul`) without/with weights,\n    - $\\begin{cases}n-1&amp;n\\ge1\\\\0&amp;n\\le1\\end{cases}$ scalar additions (`add`) &amp;\n    - one `^0.5` call.\n\n    See also\n    --------\n    - squared version without square root: [`vecabsq`][vector.functional.hilbert_space.vecabsq]\n    \"\"\"\n    #hypot(*v) doesn't work for complex\n    #math.sqrt doesn't work for complex and cmath.sqrt always returns complex\n    return vecabsq(v, weights=weights, conjugate=conjugate, zero=zero)**0.5\n</code></pre>"},{"location":"functional/#vector.functional.hilbert_space.vecabsq","title":"<code>vecabsq(v, weights=None, conjugate=False, zero=0)</code>","text":"<p>Return the sum of absolute squares.</p> \\[     ||\\vec{v}||_{\\ell_{\\mathbb{N}_0}^2}^2=\\sum_iv_i^{(*)}v_i\\omega_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}_0^+ \\] Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar conjugations (<code>conjugate</code>) (if selected),</li> <li>\\(\\begin{cases}n-1&amp;n\\ge1\\\\0&amp;n\\le1\\end{cases}\\) scalar additions (<code>add</code>) &amp;</li> <li>\\(n\\)/\\(2n\\) scalar multiplications (<code>mul</code>) without/with weights.</li> </ul> Notes <p>Reasons why it exists:</p> <ul> <li>Occurs in math.</li> <li>Most importantly: type independent because it doesn't use <code>sqrt</code>.</li> </ul> References <ul> <li>https://docs.python.org/3/library/itertools.html#itertools-recipes: <code>sum_of_squares</code></li> </ul> Source code in <code>vector\\functional\\hilbert_space.py</code> <pre><code>def vecabsq(v, weights=None, conjugate=False, zero=0):\n    r\"\"\"Return the sum of absolute squares.\n\n    $$\n        ||\\vec{v}||_{\\ell_{\\mathbb{N}_0}^2}^2=\\sum_iv_i^{(*)}v_i\\omega_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}_0^+\n    $$\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar conjugations (`conjugate`) (if selected),\n    - $\\begin{cases}n-1&amp;n\\ge1\\\\0&amp;n\\le1\\end{cases}$ scalar additions (`add`) &amp;\n    - $n$/$2n$ scalar multiplications (`mul`) without/with weights.\n\n    Notes\n    -----\n    Reasons why it exists:\n\n    - Occurs in math.\n    - Most importantly: type independent because it doesn't use `sqrt`.\n\n    References\n    ----------\n    - &lt;https://docs.python.org/3/library/itertools.html#itertools-recipes&gt;: `sum_of_squares`\n    \"\"\"\n    vc, v = tee(v, 2)\n    if conjugate:\n        vc = veclconj(vc)\n\n    if weights is None:\n        return sumprod_default(vc, v, default=zero)\n    else:\n        return sumprod_default(map(mul, vc, v), weights, default=zero)\n</code></pre>"},{"location":"functional/#vector.functional.hilbert_space.vecdot","title":"<code>vecdot(v, w, weights=None, conjugate=False, zero=0)</code>","text":"<p>Return the inner product.</p> \\[     \\left&lt;\\vec{v}\\mid\\vec{w}\\right&gt;_{\\ell_{\\mathbb{N}_0}^2}=\\sum_iv_i^{(*)}w_i\\omega_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K} \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be</p> <ul> <li>\\(\\min\\{n, m\\}\\) scalar conjugations (<code>conjugate</code>) (if selected),</li> <li>\\(\\min\\{n, m\\}\\)/\\(2\\min\\{n, m\\}\\) scalar multiplications (<code>mul</code> without/with weights) &amp;</li> <li>\\(\\begin{cases}\\min\\{n, m\\}-1&amp;n\\ge1\\land m\\ge1\\\\0&amp;n\\le1\\lor m\\le1\\end{cases}\\) scalar additions (<code>add</code>).</li> </ul> Source code in <code>vector\\functional\\hilbert_space.py</code> <pre><code>def vecdot(v, w, weights=None, conjugate=False, zero=0):\n    r\"\"\"Return the inner product.\n\n    $$\n        \\left&lt;\\vec{v}\\mid\\vec{w}\\right&gt;_{\\ell_{\\mathbb{N}_0}^2}=\\sum_iv_i^{(*)}w_i\\omega_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be\n\n    - $\\min\\{n, m\\}$ scalar conjugations (`conjugate`) (if selected),\n    - $\\min\\{n, m\\}$/$2\\min\\{n, m\\}$ scalar multiplications (`mul` without/with weights) &amp;\n    - $\\begin{cases}\\min\\{n, m\\}-1&amp;n\\ge1\\land m\\ge1\\\\0&amp;n\\le1\\lor m\\le1\\end{cases}$ scalar additions (`add`).\n    \"\"\"\n    if conjugate:\n        v = veclconj(v)\n\n    if weights is None:\n        return sumprod_default(v, w, default=zero)\n    else:\n        return sumprod_default(map(mul, v, w), weights, default=zero)\n</code></pre>"},{"location":"functional/#vector.functional.hilbert_space.vecparallel","title":"<code>vecparallel(v, w, weights=None, conjugate=False, zero=0)</code>","text":"<p>Return if two vectors are parallel.</p> \\[     \\vec{v}\\parallel\\vec{w} \\qquad ||\\vec{v}||\\,||\\vec{w}|| \\overset{?}{=} |\\vec{v}\\vec{w}|^2 \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{B} \\] Complexity <p>Not yet perfect.</p> Source code in <code>vector\\functional\\hilbert_space.py</code> <pre><code>def vecparallel(v, w, weights=None, conjugate=False, zero=0):\n    r\"\"\"Return if two vectors are parallel.\n\n    $$\n        \\vec{v}\\parallel\\vec{w} \\qquad ||\\vec{v}||\\,||\\vec{w}|| \\overset{?}{=} |\\vec{v}\\vec{w}|^2 \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{B}\n    $$\n\n    Complexity\n    ----------\n    Not yet perfect.\n    \"\"\"\n    #doesn't work for exhaustible iterables\n    #return vecabsq(v)*vecabsq(w) == abs(vecdot(v, w))**2\n    v2, w2, vw = zero, zero, zero\n    if weights is None:\n        for vi, wi in zip_longest(v, w, fillvalue=zero):\n            vic, wic = (try_conjugate(vi), try_conjugate(wi)) if conjugate else (vi, wi)\n            v2 += vic * vi\n            w2 += wic * wi\n            vw += vic * wi\n    else:\n        for vi, wi, o in zip_longest(v, w, weights, fillvalue=zero):\n            vic, wic = (try_conjugate(vi), try_conjugate(wi)) if conjugate else (vi, wi)\n            v2 += vic * vi * o\n            w2 += wic * wi * o\n            vw += vic * wi * o\n    return v2 * w2 == (try_conjugate(vw) if conjugate else vw) * vw\n</code></pre>"},{"location":"functional/#vector.functional.vector_space","title":"<code>vector_space</code>","text":""},{"location":"functional/#vector.functional.vector_space.vecpos","title":"<code>vecpos(v)</code>","text":"<p>Return the identity.</p> \\[     +\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n \\] Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar unary plus operations (<code>pos</code>).</li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecpos(v):\n    r\"\"\"Return the identity.\n\n    $$\n        +\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar unary plus operations (`pos`).\n    \"\"\"\n    return tuple(veclpos(v))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecneg","title":"<code>vecneg(v)</code>","text":"<p>Return the negation.</p> \\[     -\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n \\] Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar negations (<code>neg</code>).</li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecneg(v):\n    r\"\"\"Return the negation.\n\n    $$\n        -\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar negations (`neg`).\n    \"\"\"\n    return tuple(veclneg(v))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecadd","title":"<code>vecadd(*vs)</code>","text":"<p>Return the sum.</p> \\[     \\vec{v}_0+\\vec{v}_1+\\cdots \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i} \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be</p> <ul> <li>\\(\\min\\{n, m\\}\\) scalar additions (<code>add</code>).</li> </ul> See also <ul> <li>for sum on a single coefficient: <code>vecaddc</code></li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecadd(*vs):\n    r\"\"\"Return the sum.\n\n    $$\n        \\vec{v}_0+\\vec{v}_1+\\cdots \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i}\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be\n\n    - $\\min\\{n, m\\}$ scalar additions (`add`).\n\n    See also\n    --------\n    - for sum on a single coefficient: [`vecaddc`][vector.functional.vector_space.vecaddc]\n    \"\"\"\n    return tuple(vecladd(*vs))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecaddc","title":"<code>vecaddc(v, c, i=0, zero=0)</code>","text":"<p>Return the sum with a basis vector.</p> \\[     \\vec{v}+c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}} \\] <p>More efficient than <code>vecadd(v, vecbasis(i, c))</code>.</p> Complexity <p>There will be</p> <ul> <li>one scalar addition (<code>add</code>) if \\(i\\le n\\) or</li> <li>one unary plus operations (<code>pos</code>) otherwise.</li> </ul> See also <ul> <li>for sum on more coefficients: <code>vecadd</code></li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecaddc(v, c, i=0, zero=0):\n    r\"\"\"Return the sum with a basis vector.\n\n    $$\n        \\vec{v}+c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}}\n    $$\n\n    More efficient than `vecadd(v, vecbasis(i, c))`.\n\n    Complexity\n    ----------\n    There will be\n\n    - one scalar addition (`add`) if $i\\le n$ or\n    - one unary plus operations (`pos`) otherwise.\n\n    See also\n    --------\n    - for sum on more coefficients: [`vecadd`][vector.functional.vector_space.vecadd]\n    \"\"\"\n    return tuple(vecladdc(v, c, i=i, zero=zero))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecsub","title":"<code>vecsub(v, w)</code>","text":"<p>Return the difference.</p> \\[     \\vec{v}-\\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{m, n\\}} \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be</p> <ul> <li>\\(\\min\\{n, m\\}\\) scalar subtractions (<code>sub</code>) &amp;</li> <li>\\(\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}\\) negations (<code>neg</code>).</li> </ul> See also <ul> <li>for difference on a single coefficient: <code>vecsubc</code></li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecsub(v, w):\n    r\"\"\"Return the difference.\n\n    $$\n        \\vec{v}-\\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{m, n\\}}\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be\n\n    - $\\min\\{n, m\\}$ scalar subtractions (`sub`) &amp;\n    - $\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}$ negations (`neg`).\n\n    See also\n    --------\n    - for difference on a single coefficient: [`vecsubc`][vector.functional.vector_space.vecsubc]\n    \"\"\"\n    return tuple(veclsub(v, w))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecsubc","title":"<code>vecsubc(v, c, i=0, zero=0)</code>","text":"<p>Return the difference with a basis vector.</p> \\[     \\vec{v}-c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}} \\] <p>More efficient than <code>vecsub(v, vecbasis(i, c))</code>.</p> Complexity <p>There will be</p> <ul> <li>one scalar subtraction (<code>sub</code>) if \\(i\\le n\\) or</li> <li>one scalar negation (<code>neg</code>) otherwise.</li> </ul> See also <ul> <li>for difference on more coefficients: <code>vecsub</code></li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecsubc(v, c, i=0, zero=0):\n    r\"\"\"Return the difference with a basis vector.\n\n    $$\n        \\vec{v}-c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}}\n    $$\n\n    More efficient than `vecsub(v, vecbasis(i, c))`.\n\n    Complexity\n    ----------\n    There will be\n\n    - one scalar subtraction (`sub`) if $i\\le n$ or\n    - one scalar negation (`neg`) otherwise.\n\n    See also\n    --------\n    - for difference on more coefficients: [`vecsub`][vector.functional.vector_space.vecsub]\n    \"\"\"\n    return tuple(veclsubc(v, c, i=i, zero=zero))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecmul","title":"<code>vecmul(v, a)</code>","text":"<p>Return the product.</p> \\[     \\vec{v}a \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n \\] Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar multiplications (<code>rmul</code>).</li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecmul(v, a):\n    r\"\"\"Return the product.\n\n    $$\n        \\vec{v}a \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar multiplications (`rmul`).\n    \"\"\"\n    return tuple(veclmul(v, a))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecrmul","title":"<code>vecrmul(a, v)</code>","text":"<p>Return the product.</p> \\[     a\\vec{v} \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n \\] Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar multiplications (<code>rmul</code>).</li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecrmul(a, v):\n    r\"\"\"Return the product.\n\n    $$\n        a\\vec{v} \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar multiplications (`rmul`).\n    \"\"\"\n    return tuple(veclrmul(a, v))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vectruediv","title":"<code>vectruediv(v, a)</code>","text":"<p>Return the true quotient.</p> \\[     \\frac{\\vec{v}}{a} \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n \\] Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar true divisions (<code>truediv</code>).</li> </ul> Notes <p>Why called <code>truediv</code> instead of <code>div</code>?</p> <ul> <li><code>div</code> would be more appropriate for an absolute clean mathematical implementation, that doesn't care about the language used. But the package might be used for pure integers/integer arithmetic, so both, <code>truediv</code> and <code>floordiv</code> operations have to be provided, and none should be privileged over the other by getting the universal <code>div</code> name.</li> <li><code>truediv</code>/<code>floordiv</code> is unambiguous, like Python <code>operator</code>s.</li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vectruediv(v, a):\n    r\"\"\"Return the true quotient.\n\n    $$\n        \\frac{\\vec{v}}{a} \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\n    $$\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar true divisions (`truediv`).\n\n    Notes\n    -----\n    Why called `truediv` instead of `div`?\n\n    - `div` would be more appropriate for an absolute clean mathematical\n    implementation, that doesn't care about the language used. But the package\n    might be used for pure integers/integer arithmetic, so both, `truediv`\n    and `floordiv` operations have to be provided, and none should be\n    privileged over the other by getting the universal `div` name.\n    - `truediv`/`floordiv` is unambiguous, like Python `operator`s.\n    \"\"\"\n    return tuple(vecltruediv(v, a))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecfloordiv","title":"<code>vecfloordiv(v, a)</code>","text":"<p>Return the floor quotient.</p> \\[     \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n \\] Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar floor divisions (<code>floordiv</code>).</li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecfloordiv(v, a):\n    r\"\"\"Return the floor quotient.\n\n    $$\n        \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\n    $$\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar floor divisions (`floordiv`).\n    \"\"\"\n    return tuple(veclfloordiv(v, a))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecmod","title":"<code>vecmod(v, a)</code>","text":"<p>Return the remainder.</p> \\[     \\vec{v} \\bmod a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n \\] Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar modulos (<code>mod</code>).</li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecmod(v, a):\n    r\"\"\"Return the remainder.\n\n    $$\n        \\vec{v} \\bmod a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\n    $$\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar modulos (`mod`).\n    \"\"\"\n    return tuple(veclmod(v, a))\n</code></pre>"},{"location":"functional/#vector.functional.vector_space.vecdivmod","title":"<code>vecdivmod(v, a)</code>","text":"<p>Return the floor quotient and remainder.</p> \\[     \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor, \\ \\left(\\vec{v} \\bmod a\\right) \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\\times\\mathbb{K}^n \\] Complexity <p>For a vector of length \\(n\\) there will be</p> <ul> <li>\\(n\\) scalar divmods (<code>divmod</code>).</li> </ul> Source code in <code>vector\\functional\\vector_space.py</code> <pre><code>def vecdivmod(v, a):\n    r\"\"\"Return the floor quotient and remainder.\n\n    $$\n        \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor, \\ \\left(\\vec{v} \\bmod a\\right) \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\\times\\mathbb{K}^n\n    $$\n\n    Complexity\n    ----------\n    For a vector of length $n$ there will be\n\n    - $n$ scalar divmods (`divmod`).\n    \"\"\"\n    q, r = [], []\n    for vi in v:\n        qi, ri = divmod(vi, a)\n        q.append(qi)\n        r.append(ri)\n    return tuple(q), tuple(r)\n</code></pre>"},{"location":"functional/#vector.functional.elementwise","title":"<code>elementwise</code>","text":""},{"location":"functional/#vector.functional.elementwise.vechadamard","title":"<code>vechadamard(*vs)</code>","text":"<p>Return the elementwise product.</p> \\[     \\left((\\vec{v}_0)_i\\cdot(\\vec{v}_1)_i\\cdot\\cdots\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\min_i n_i} \\] Complexity <p>For vectors of lengths \\(n_1, n_2, \\dots, n_N\\) there will be</p> <ul> <li>\\(\\begin{cases}(N-1)\\min_in_i&amp;N\\ge1\\land\\min_in_i\\ge1\\\\0&amp;N\\le1\\lor\\min_in_i=0\\end{cases}\\) scalar multiplications (<code>mul</code>).</li> </ul> Source code in <code>vector\\functional\\elementwise.py</code> <pre><code>def vechadamard(*vs):\n    r\"\"\"Return the elementwise product.\n\n    $$\n        \\left((\\vec{v}_0)_i\\cdot(\\vec{v}_1)_i\\cdot\\cdots\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\min_i n_i}\n    $$\n\n    Complexity\n    ----------\n    For vectors of lengths $n_1, n_2, \\dots, n_N$ there will be\n\n    - $\\begin{cases}(N-1)\\min_in_i&amp;N\\ge1\\land\\min_in_i\\ge1\\\\0&amp;N\\le1\\lor\\min_in_i=0\\end{cases}$ scalar multiplications (`mul`).\n    \"\"\"\n    return tuple(veclhadamard(*vs))\n</code></pre>"},{"location":"functional/#vector.functional.elementwise.vechadamardtruediv","title":"<code>vechadamardtruediv(v, w)</code>","text":"<p>Return the elementwise true quotient.</p> \\[     \\left(\\frac{v_i}{w_i}\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be</p> <ul> <li>\\(n\\) scalar true divisions (<code>truediv</code>).</li> </ul> Source code in <code>vector\\functional\\elementwise.py</code> <pre><code>def vechadamardtruediv(v, w):\n    r\"\"\"Return the elementwise true quotient.\n\n    $$\n        \\left(\\frac{v_i}{w_i}\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be\n\n    - $n$ scalar true divisions (`truediv`).\n    \"\"\"\n    return tuple(veclhadamardtruediv(v, w))\n</code></pre>"},{"location":"functional/#vector.functional.elementwise.vechadamardfloordiv","title":"<code>vechadamardfloordiv(v, w)</code>","text":"<p>Return the elementwise floor quotient.</p> \\[     \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be</p> <ul> <li>\\(n\\) scalar floor divisions (<code>floordiv</code>).</li> </ul> Source code in <code>vector\\functional\\elementwise.py</code> <pre><code>def vechadamardfloordiv(v, w):\n    r\"\"\"Return the elementwise floor quotient.\n\n    $$\n        \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be\n\n    - $n$ scalar floor divisions (`floordiv`).\n    \"\"\"\n    return tuple(veclhadamardfloordiv(v, w))\n</code></pre>"},{"location":"functional/#vector.functional.elementwise.vechadamardmod","title":"<code>vechadamardmod(v, w)</code>","text":"<p>Return the elementwise remainder.</p> \\[     \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be</p> <ul> <li>\\(n\\) scalar modulos (<code>mod</code>).</li> </ul> Source code in <code>vector\\functional\\elementwise.py</code> <pre><code>def vechadamardmod(v, w):\n    r\"\"\"Return the elementwise remainder.\n\n    $$\n        \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be\n\n    - $n$ scalar modulos (`mod`).\n    \"\"\"\n    return tuple(veclhadamardmod(v, w))\n</code></pre>"},{"location":"functional/#vector.functional.elementwise.vechadamarddivmod","title":"<code>vechadamarddivmod(v, w)</code>","text":"<p>Return the elementwise floor quotient and remainder.</p> \\[     \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i, \\ \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^n\\times\\mathbb{K}^m\\to\\mathbb{K}^n\\times\\mathbb{K}^n \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be</p> <ul> <li>\\(n\\) scalar divmods (<code>divmod</code>).</li> </ul> Source code in <code>vector\\functional\\elementwise.py</code> <pre><code>def vechadamarddivmod(v, w):\n    r\"\"\"Return the elementwise floor quotient and remainder.\n\n    $$\n        \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i, \\ \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^n\\times\\mathbb{K}^m\\to\\mathbb{K}^n\\times\\mathbb{K}^n\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be\n\n    - $n$ scalar divmods (`divmod`).\n    \"\"\"\n    q, r = [], []\n    for qi, ri in veclhadamarddivmod(v, w):\n        q.append(qi)\n        r.append(ri)\n    return tuple(q), tuple(r)\n</code></pre>"},{"location":"functional/#vector.functional.elementwise.vechadamardmin","title":"<code>vechadamardmin(*vs, key=None)</code>","text":"<p>Return the elementwise minimum.</p> \\[     \\left(\\min((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i} \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be</p> <ul> <li>\\(\\min\\{n, m\\}\\) comparisons (<code>lt</code>).</li> </ul> Source code in <code>vector\\functional\\elementwise.py</code> <pre><code>def vechadamardmin(*vs, key=None):\n    r\"\"\"Return the elementwise minimum.\n\n    $$\n        \\left(\\min((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i}\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be\n\n    - $\\min\\{n, m\\}$ comparisons (`lt`).\n    \"\"\"\n    return tuple(veclhadamardmin(*vs, key=key))\n</code></pre>"},{"location":"functional/#vector.functional.elementwise.vechadamardmax","title":"<code>vechadamardmax(*vs, key=None)</code>","text":"<p>Return the elementwise maximum.</p> \\[     \\left(\\max((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i} \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be</p> <ul> <li>\\(\\min\\{n, m\\}\\) comparisons (<code>gt</code>).</li> </ul> Source code in <code>vector\\functional\\elementwise.py</code> <pre><code>def vechadamardmax(*vs, key=None):\n    r\"\"\"Return the elementwise maximum.\n\n    $$\n        \\left(\\max((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i}\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be\n\n    - $\\min\\{n, m\\}$ comparisons (`gt`).\n    \"\"\"\n    return tuple(veclhadamardmax(*vs, key=key))\n</code></pre>"},{"location":"inplace/","title":"In-place","text":"<p>Vector in-place operations.</p> <pre><code>&gt;&gt;&gt; from vector import vecimul\n&gt;&gt;&gt; v = [1, 2, 3]\n&gt;&gt;&gt; vecimul(2, v)\n[2, 4, 6]\n&gt;&gt;&gt; v\n[2, 4, 6]\n</code></pre> <p>Prefixed by <code>veci...</code> (vector - in-place).</p> <p>All functions accept vectors as lists.</p> <p>They modify them in-place.</p> <p>The functions are type-independent. However, the coefficients used must support necessary scalar operations. For instance, for vector addition, coefficients must be addable.</p> <p>For complete type safety a zero argument is available. Default is <code>int(0)</code>.</p>"},{"location":"inplace/#vector.inplace--docstring-conventions","title":"Docstring conventions","text":"<p>Summary</p> <p>Math notation (vector notation if possible, index notation, domain &amp; codomain)</p> <p>More information (\"More efficient than ...\").</p> Notes <p>Design choices</p> See also <p>Similar functions</p> References <p>Wikipedia, numpy, ...</p>"},{"location":"inplace/#vector.inplace.creation","title":"<code>creation</code>","text":""},{"location":"inplace/#vector.inplace.creation.vecizero","title":"<code>vecizero()</code>","text":"<p>Return a zero vector.</p> \\[     \\vec{0} \\qquad \\mathbb{K}^0 \\] <p>An empty list: <code>[]</code>.</p> Source code in <code>vector\\inplace\\creation.py</code> <pre><code>def vecizero():\n    r\"\"\"Return a zero vector.\n\n    $$\n        \\vec{0} \\qquad \\mathbb{K}^0\n    $$\n\n    An empty list: `[]`.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"inplace/#vector.inplace.creation.vecibasis","title":"<code>vecibasis(i, c=1, zero=0)</code>","text":"<p>Return a basis vector.</p> \\[     c\\vec{e}_i \\qquad \\mathbb{K}^{i+1} \\] <p>Returns a list with <code>i</code> many <code>zero</code>s followed by <code>c</code>.</p> See also <ul> <li>for all basis vectors: <code>vecibases</code></li> </ul> Source code in <code>vector\\inplace\\creation.py</code> <pre><code>def vecibasis(i, c=1, zero=0):\n    r\"\"\"Return a basis vector.\n\n    $$\n        c\\vec{e}_i \\qquad \\mathbb{K}^{i+1}\n    $$\n\n    Returns a list with `i` many `zero`s followed by `c`.\n\n    See also\n    --------\n    - for all basis vectors: [`vecibases`][vector.inplace.creation.vecibases]\n    \"\"\"\n    return [zero]*i + [c]\n</code></pre>"},{"location":"inplace/#vector.inplace.creation.vecibases","title":"<code>vecibases(start=0, c=1, zero=0)</code>","text":"<p>Yield all basis vectors.</p> \\[     \\left(\\vec{e}_n\\right)_{n\\in\\mathbb{N}_{\\geq\\text{start}}} = \\left(\\vec{e}_\\text{start}, \\vec{e}_{\\text{start}+1}, \\dots \\right) \\] See also <ul> <li>for single basis vector: <code>vecibasis</code></li> </ul> Source code in <code>vector\\inplace\\creation.py</code> <pre><code>def vecibases(start=0, c=1, zero=0):\n    r\"\"\"Yield all basis vectors.\n\n    $$\n        \\left(\\vec{e}_n\\right)_{n\\in\\mathbb{N}_{\\geq\\text{start}}} = \\left(\\vec{e}_\\text{start}, \\vec{e}_{\\text{start}+1}, \\dots \\right)\n    $$\n\n    See also\n    --------\n    - for single basis vector: [`vecibasis`][vector.inplace.creation.vecibasis]\n    \"\"\"\n    for i in count(start=start):\n        yield vecibasis(i, c=c, zero=zero)\n</code></pre>"},{"location":"inplace/#vector.inplace.creation.vecirand","title":"<code>vecirand(n)</code>","text":"<p>Return a random vector of uniform sampled <code>float</code> coefficients.</p> \\[     \\vec{v}\\sim\\mathcal{U}^n([0, 1[) \\qquad \\mathbb{K}^n \\] <p>The coefficients are sampled from a uniform distribution in <code>[0, 1[</code>.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\inplace\\creation.py</code> <pre><code>def vecirand(n):\n    r\"\"\"Return a random vector of uniform sampled `float` coefficients.\n\n    $$\n        \\vec{v}\\sim\\mathcal{U}^n([0, 1[) \\qquad \\mathbb{K}^n\n    $$\n\n    The coefficients are sampled from a uniform distribution in `[0, 1[`.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    return list(veclrand(n))\n</code></pre>"},{"location":"inplace/#vector.inplace.creation.vecirandn","title":"<code>vecirandn(n, normed=True, mu=0, sigma=1, weights=None)</code>","text":"<p>Return a random vector of normal sampled <code>float</code> coefficients.</p> \\[     \\vec{v}\\sim\\mathcal{N}^n(\\mu, \\sigma) \\qquad \\mathbb{K}^n \\] <p>The coefficients are sampled from a normal distribution.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\inplace\\creation.py</code> <pre><code>def vecirandn(n, normed=True, mu=0, sigma=1, weights=None):\n    r\"\"\"Return a random vector of normal sampled `float` coefficients.\n\n    $$\n        \\vec{v}\\sim\\mathcal{N}^n(\\mu, \\sigma) \\qquad \\mathbb{K}^n\n    $$\n\n    The coefficients are sampled from a normal distribution.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    v = list(veclrandn(n, mu, sigma))\n    return vecitruediv(v, vecabs(v, weights)) if normed else v\n</code></pre>"},{"location":"inplace/#vector.inplace.utility","title":"<code>utility</code>","text":""},{"location":"inplace/#vector.inplace.utility.vecitrim","title":"<code>vecitrim(v, tol=None)</code>","text":"<p>Remove all trailing near zero (<code>abs(v_i)&lt;=tol</code>) coefficients.</p> \\[     \\begin{pmatrix}         v_0 \\\\         \\vdots \\\\         v_m     \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_j|&gt;\\text{tol}\\,\\}\\cup\\{-1\\} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\leq n} \\] <p><code>tol</code> may also be <code>None</code>, then all coefficients that evaluate to <code>False</code> are trimmed.</p> Notes <ul> <li>Cutting of elements that are <code>abs(v_i)&lt;=tol</code> instead of <code>abs(v_i)&lt;tol</code> to allow cutting of elements that are exactly zero by <code>trim(v, 0)</code> instead of <code>trim(v, sys.float_info.min)</code>.</li> </ul> Source code in <code>vector\\inplace\\utility.py</code> <pre><code>def vecitrim(v, tol=None):\n    r\"\"\"Remove all trailing near zero (`abs(v_i)&lt;=tol`) coefficients.\n\n    $$\n        \\begin{pmatrix}\n            v_0 \\\\\n            \\vdots \\\\\n            v_m\n        \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_j|&gt;\\text{tol}\\,\\}\\cup\\{-1\\} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\leq n}\n    $$\n\n    `tol` may also be `None`,\n    then all coefficients that evaluate to `False` are trimmed.\n\n    Notes\n    -----\n    - Cutting of elements that are `abs(v_i)&lt;=tol` instead of `abs(v_i)&lt;tol` to\n    allow cutting of elements that are exactly zero by `trim(v, 0)` instead\n    of `trim(v, sys.float_info.min)`.\n    \"\"\"\n    while v and (not v[-1] if tol is None else abs(v[-1])&lt;=tol):\n        v.pop()\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.utility.vecirshift","title":"<code>vecirshift(v, n, zero=0)</code>","text":"<p>Shift coefficients up.</p> \\[     (v_{i-n})_i \\qquad \\begin{pmatrix}         0 \\\\         \\vdots \\\\         0 \\\\         v_0 \\\\         v_1 \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n} \\] Source code in <code>vector\\inplace\\utility.py</code> <pre><code>def vecirshift(v, n, zero=0):\n    r\"\"\"Shift coefficients up.\n\n    $$\n        (v_{i-n})_i \\qquad \\begin{pmatrix}\n            0 \\\\\n            \\vdots \\\\\n            0 \\\\\n            v_0 \\\\\n            v_1 \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n}\n    $$\n    \"\"\"\n    v[:0] = [zero] * n\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.utility.vecilshift","title":"<code>vecilshift(v, n)</code>","text":"<p>Shift coefficients down.</p> \\[     (v_{i+n})_i \\qquad \\begin{pmatrix}         v_n \\\\         v_{n+1} \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}} \\] Source code in <code>vector\\inplace\\utility.py</code> <pre><code>def vecilshift(v, n):\n    r\"\"\"Shift coefficients down.\n\n    $$\n        (v_{i+n})_i \\qquad \\begin{pmatrix}\n            v_n \\\\\n            v_{n+1} \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}}\n    $$\n    \"\"\"\n    del v[:n]\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.hilbert_space","title":"<code>hilbert_space</code>","text":""},{"location":"inplace/#vector.inplace.hilbert_space.veciconj","title":"<code>veciconj(v)</code>","text":"<p>Complex conjugate.</p> \\[     \\vec{v} = \\vec{v}^* \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n \\] <p>Tries to call a method <code>conjugate</code> on each element. If not found, simply keeps the element as is.</p> Source code in <code>vector\\inplace\\hilbert_space.py</code> <pre><code>def veciconj(v):\n    r\"\"\"Complex conjugate.\n\n    $$\n        \\vec{v} = \\vec{v}^* \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n\n    Tries to call a method `conjugate` on each element.\n    If not found, simply keeps the element as is.\n    \"\"\"\n    for i, vi in enumerate(v):\n        v[i] = try_conjugate(vi)\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space","title":"<code>vector_space</code>","text":""},{"location":"inplace/#vector.inplace.vector_space.vecipos","title":"<code>vecipos(v)</code>","text":"<p>Apply unary positive.</p> \\[     \\vec{v} = +\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n \\] Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def vecipos(v):\n    r\"\"\"Apply unary positive.\n\n    $$\n        \\vec{v} = +\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    for i, vi in enumerate(v):\n        v[i] = +vi\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space.vecineg","title":"<code>vecineg(v)</code>","text":"<p>Negate.</p> \\[     \\vec{v} = -\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n \\] Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def vecineg(v):\n    r\"\"\"Negate.\n\n    $$\n        \\vec{v} = -\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    for i, vi in enumerate(v):\n        v[i] = -vi\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space.veciadd","title":"<code>veciadd(v, *ws)</code>","text":"<p>Add.</p> \\[     \\vec{v} += \\vec{w}_0+\\vec{w}_1+\\cdots \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i} \\] See also <ul> <li>for sum on a single coefficient: <code>veciaddc</code></li> </ul> Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def veciadd(v, *ws):\n    r\"\"\"Add.\n\n    $$\n        \\vec{v} += \\vec{w}_0+\\vec{w}_1+\\cdots \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i}\n    $$\n\n    See also\n    --------\n    - for sum on a single coefficient: [`veciaddc`][vector.inplace.vector_space.veciaddc]\n    \"\"\"\n    if ws:\n        #extract longest vector so we only have to extend once\n        longest = max(ws, key=len)\n        ws = tuple(w for w in ws if w is not longest)\n        #add longest vector\n        for i, wi in enumerate(longest[:len(v)]):\n            v[i] += wi\n        v.extend(longest[len(v):])\n        #add others\n        for w in ws:\n            for i, wi in enumerate(w):\n                v[i] += wi\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space.veciaddc","title":"<code>veciaddc(v, c, i=0, zero=0)</code>","text":"<p>Add a basis vector.</p> \\[     \\vec{v} += c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}} \\] <p>More efficient than <code>veciadd(v, vecibasis(i, c))</code>.</p> See also <ul> <li>for sum on more coefficients: <code>veciadd</code></li> </ul> Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def veciaddc(v, c, i=0, zero=0):\n    r\"\"\"Add a basis vector.\n\n    $$\n        \\vec{v} += c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}}\n    $$\n\n    More efficient than `veciadd(v, vecibasis(i, c))`.\n\n    See also\n    --------\n    - for sum on more coefficients: [`veciadd`][vector.inplace.vector_space.veciadd]\n    \"\"\"\n    if i &gt;= len(v):\n        v.extend([zero] * (i-len(v)))\n        v.append(c)\n    else:\n        v[i] += c\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space.vecisub","title":"<code>vecisub(v, w)</code>","text":"<p>Subtract.</p> \\[     \\vec{v} -= \\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{m, n\\}} \\] See also <ul> <li>for difference on a single coefficient: <code>vecisubc</code></li> </ul> Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def vecisub(v, w):\n    r\"\"\"Subtract.\n\n    $$\n        \\vec{v} -= \\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{m, n\\}}\n    $$\n\n    See also\n    --------\n    - for difference on a single coefficient: [`vecisubc`][vector.inplace.vector_space.vecisubc]\n    \"\"\"\n    for i, wi in enumerate(w[:len(v)]):\n        v[i] -= wi\n    if len(w) &gt; len(v):\n        v.extend([-wi for wi in w[len(v):]])\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space.vecisubc","title":"<code>vecisubc(v, c, i=0, zero=0)</code>","text":"<p>Subtract a basis vector.</p> \\[     \\vec{v} -= c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}} \\] <p>More efficient than <code>vecisub(v, vecibasis(i, c))</code>.</p> See also <ul> <li>for difference on more coefficients: <code>vecisub</code></li> </ul> Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def vecisubc(v, c, i=0, zero=0):\n    r\"\"\"Subtract a basis vector.\n\n    $$\n        \\vec{v} -= c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}}\n    $$\n\n    More efficient than `vecisub(v, vecibasis(i, c))`.\n\n    See also\n    --------\n    - for difference on more coefficients: [`vecisub`][vector.inplace.vector_space.vecisub]\n    \"\"\"\n    if i &gt;= len(v):\n        v.extend([zero] * (i-len(v)))\n        v.append(-c)\n    else:\n        v[i] -= c\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space.vecimul","title":"<code>vecimul(v, a)</code>","text":"<p>Multiply.</p> \\[     \\vec{v} \\cdot= a \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n \\] Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def vecimul(v, a):\n    r\"\"\"Multiply.\n\n    $$\n        \\vec{v} \\cdot= a \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    for i in range(len(v)):\n        v[i] *= a\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space.vecitruediv","title":"<code>vecitruediv(v, a)</code>","text":"<p>True divide.</p> \\[     \\vec{v} /= a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n \\] Notes <p>Why called <code>truediv</code> instead of <code>div</code>?</p> <ul> <li><code>div</code> would be more appropriate for an absolute clean mathematical implementation, that doesn't care about the language used. But the package might be used for pure integers/integer arithmetic, so both, <code>truediv</code> and <code>floordiv</code> operations have to be provided, and none should be privileged over the other by getting the universal <code>div</code> name.</li> <li><code>truediv</code>/<code>floordiv</code> is unambiguous, like Python <code>operator</code>s.</li> </ul> Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def vecitruediv(v, a):\n    r\"\"\"True divide.\n\n    $$\n        \\vec{v} /= a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\n    $$\n\n    Notes\n    -----\n    Why called `truediv` instead of `div`?\n\n    - `div` would be more appropriate for an absolute clean mathematical\n    implementation, that doesn't care about the language used. But the package\n    might be used for pure integers/integer arithmetic, so both, `truediv`\n    and `floordiv` operations have to be provided, and none should be\n    privileged over the other by getting the universal `div` name.\n    - `truediv`/`floordiv` is unambiguous, like Python `operator`s.\n    \"\"\"\n    for i in range(len(v)):\n        v[i] /= a\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space.vecifloordiv","title":"<code>vecifloordiv(v, a)</code>","text":"<p>Floor divide.</p> \\[     \\vec{v} //= a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n \\] Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def vecifloordiv(v, a):\n    r\"\"\"Floor divide.\n\n    $$\n        \\vec{v} //= a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    for i in range(len(v)):\n        v[i] //= a\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.vector_space.vecimod","title":"<code>vecimod(v, a)</code>","text":"<p>Mod.</p> \\[     \\vec{v} \\%= a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n \\] Source code in <code>vector\\inplace\\vector_space.py</code> <pre><code>def vecimod(v, a):\n    r\"\"\"Mod.\n\n    $$\n        \\vec{v} \\%= a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    for i in range(len(v)):\n        v[i] %= a\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.elementwise","title":"<code>elementwise</code>","text":""},{"location":"inplace/#vector.inplace.elementwise.vecihadamard","title":"<code>vecihadamard(v, *ws)</code>","text":"<p>Return the elementwise product.</p> \\[     \\left((\\vec{v})_i\\cdot(\\vec{w}_0)_i\\cdot(\\vec{w}_1)_i\\cdot\\cdots\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\min_i n_i} \\] Source code in <code>vector\\inplace\\elementwise.py</code> <pre><code>def vecihadamard(v, *ws):\n    r\"\"\"Return the elementwise product.\n\n    $$\n        \\left((\\vec{v})_i\\cdot(\\vec{w}_0)_i\\cdot(\\vec{w}_1)_i\\cdot\\cdots\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\min_i n_i}\n    $$\n    \"\"\"\n    if ws:\n        del v[min(len(w) for w in ws):]\n        for w in ws:\n            for i, wi in enumerate(w[:len(v)]):\n                v[i] *= wi\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.elementwise.vecihadamardtruediv","title":"<code>vecihadamardtruediv(v, w)</code>","text":"<p>Return the elementwise true quotient.</p> \\[     \\left(\\frac{v_i}{w_i}\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m \\] Source code in <code>vector\\inplace\\elementwise.py</code> <pre><code>def vecihadamardtruediv(v, w):\n    r\"\"\"Return the elementwise true quotient.\n\n    $$\n        \\left(\\frac{v_i}{w_i}\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m\n    $$\n    \"\"\"\n    for i in range(len(v)):\n        v[i] /= w[i]\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.elementwise.vecihadamardfloordiv","title":"<code>vecihadamardfloordiv(v, w)</code>","text":"<p>Return the elementwise floor quotient.</p> \\[     \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m \\] Source code in <code>vector\\inplace\\elementwise.py</code> <pre><code>def vecihadamardfloordiv(v, w):\n    r\"\"\"Return the elementwise floor quotient.\n\n    $$\n        \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m\n    $$\n    \"\"\"\n    for i in range(len(v)):\n        v[i] //= w[i]\n    return v\n</code></pre>"},{"location":"inplace/#vector.inplace.elementwise.vecihadamardmod","title":"<code>vecihadamardmod(v, w)</code>","text":"<p>Return the elementwise remainder.</p> \\[     \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m \\] Source code in <code>vector\\inplace\\elementwise.py</code> <pre><code>def vecihadamardmod(v, w):\n    r\"\"\"Return the elementwise remainder.\n\n    $$\n        \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m\n    $$\n    \"\"\"\n    for i in range(len(v)):\n        v[i] %= w[i]\n    return v\n</code></pre>"},{"location":"lazy/","title":"Lazy","text":"<p>Vector operations as lazy generators.</p> <pre><code>&gt;&gt;&gt; from vector import veclbasis\n&gt;&gt;&gt; veclbasis(3)\n&lt;generator object veclbasis at 0x0123456789ABCDEF&gt;\n&gt;&gt;&gt; tuple(veclbasis(3))\n(0, 0, 0, 1)\n</code></pre> <p>Prefixed by <code>vecl...</code> (vector - lazy).</p> <p>Functions are generators.</p> <p>Lazy generator versions of <code>functional</code>.</p> <p>Different behaviour:</p> <ul> <li><code>vecrandn</code>: normalisation not possible.</li> </ul> <p>Not implemented lazily as these are consumers:</p> <ul> <li><code>vecabs</code></li> <li><code>vecabsq</code></li> <li><code>vecdot</code></li> <li><code>vecparallel</code></li> </ul>"},{"location":"lazy/#vector.lazy.creation","title":"<code>creation</code>","text":""},{"location":"lazy/#vector.lazy.creation.veclzero","title":"<code>veclzero()</code>","text":"<p>Zero vector.</p> \\[     \\vec{0} \\qquad \\mathbb{K}^0 \\] <p>An empty generator.</p> Source code in <code>vector\\lazy\\creation.py</code> <pre><code>def veclzero():\n    r\"\"\"Zero vector.\n\n    $$\n        \\vec{0} \\qquad \\mathbb{K}^0\n    $$\n\n    An empty generator.\n    \"\"\"\n    yield from ()\n</code></pre>"},{"location":"lazy/#vector.lazy.creation.veclbasis","title":"<code>veclbasis(i, c=1, zero=0)</code>","text":"<p>Return a basis vector.</p> \\[     c\\vec{e}_i \\qquad \\mathbb{K}^{i+1} \\] <p>Yields <code>i</code> zeros followed by <code>c</code>.</p> See also <ul> <li>for all basis vectors: <code>veclbases</code></li> </ul> Source code in <code>vector\\lazy\\creation.py</code> <pre><code>def veclbasis(i, c=1, zero=0):\n    r\"\"\"Return a basis vector.\n\n    $$\n        c\\vec{e}_i \\qquad \\mathbb{K}^{i+1}\n    $$\n\n    Yields `i` zeros followed by `c`.\n\n    See also\n    --------\n    - for all basis vectors: [`veclbases`][vector.lazy.creation.veclbases]\n    \"\"\"\n    yield from chain(repeat(zero, i), (c,))\n</code></pre>"},{"location":"lazy/#vector.lazy.creation.veclbases","title":"<code>veclbases(start=0, c=1, zero=0)</code>","text":"<p>Yield all basis vectors.</p> \\[     \\left(\\vec{e}_n\\right)_{n\\in\\mathbb{N}_{\\geq\\text{start}}} = \\left(\\vec{e}_\\text{start}, \\vec{e}_{\\text{start}+1}, \\dots \\right) \\] See also <ul> <li>for single basis vector: <code>veclbasis</code></li> </ul> Source code in <code>vector\\lazy\\creation.py</code> <pre><code>def veclbases(start=0, c=1, zero=0):\n    r\"\"\"Yield all basis vectors.\n\n    $$\n        \\left(\\vec{e}_n\\right)_{n\\in\\mathbb{N}_{\\geq\\text{start}}} = \\left(\\vec{e}_\\text{start}, \\vec{e}_{\\text{start}+1}, \\dots \\right)\n    $$\n\n    See also\n    --------\n    - for single basis vector: [`veclbasis`][vector.lazy.creation.veclbases]\n    \"\"\"\n    for i in count(start=start):\n        yield veclbasis(i, c=c, zero=zero)\n</code></pre>"},{"location":"lazy/#vector.lazy.creation.veclrand","title":"<code>veclrand(n)</code>","text":"<p>Return a random vector of uniform sampled <code>float</code> coefficients.</p> \\[     \\vec{v}\\sim\\mathcal{U}^n([0, 1[) \\qquad \\mathbb{K}^n \\] <p>The coefficients are sampled from a uniform distribution in <code>[0, 1[</code>.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\lazy\\creation.py</code> <pre><code>def veclrand(n):\n    r\"\"\"Return a random vector of uniform sampled `float` coefficients.\n\n    $$\n        \\vec{v}\\sim\\mathcal{U}^n([0, 1[) \\qquad \\mathbb{K}^n\n    $$\n\n    The coefficients are sampled from a uniform distribution in `[0, 1[`.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    yield from (random() for _ in range(n))\n</code></pre>"},{"location":"lazy/#vector.lazy.creation.veclrandn","title":"<code>veclrandn(n, mu=0, sigma=1)</code>","text":"<p>Return a random vector of normal sampled <code>float</code> coefficients.</p> \\[     \\vec{v}\\sim\\mathcal{N}^n(\\mu, \\sigma) \\qquad \\mathbb{K}^n \\] <p>The coefficients are sampled from a normal distribution.</p> <p>Difference to <code>vecrandn</code>: The vector can't be normalised as it isn't materialised.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\lazy\\creation.py</code> <pre><code>def veclrandn(n, mu=0, sigma=1):\n    r\"\"\"Return a random vector of normal sampled `float` coefficients.\n\n    $$\n        \\vec{v}\\sim\\mathcal{N}^n(\\mu, \\sigma) \\qquad \\mathbb{K}^n\n    $$\n\n    The coefficients are sampled from a normal distribution.\n\n    Difference to [`vecrandn`][vector.functional.vecrandn]:\n    The vector can't be normalised as it isn't materialised.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    yield from (gauss(mu, sigma) for _ in range(n))\n</code></pre>"},{"location":"lazy/#vector.lazy.utility","title":"<code>utility</code>","text":""},{"location":"lazy/#vector.lazy.utility.vecleq","title":"<code>vecleq(v, w)</code>","text":"<p>Return if two vectors are equal.</p> \\[     \\vec{v}=\\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{B} \\] Source code in <code>vector\\lazy\\utility.py</code> <pre><code>def vecleq(v, w):\n    r\"\"\"Return if two vectors are equal.\n\n    $$\n        \\vec{v}=\\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{B}\n    $$\n    \"\"\"\n    sentinel = object()\n    for vi, wi in zip_longest(v, w, fillvalue=sentinel):\n        if wi is sentinel:\n            yield not bool(vi)\n        elif vi is sentinel:\n            yield not bool(wi)\n        else:\n            yield vi == wi\n</code></pre>"},{"location":"lazy/#vector.lazy.utility.vecltrim","title":"<code>vecltrim(v, tol=None)</code>","text":"<p>Remove all trailing near zero (<code>abs(v_i)&lt;=tol</code>) coefficients.</p> \\[     \\begin{pmatrix}         v_0 \\\\         \\vdots \\\\         v_m     \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_{j-1}|&gt;\\text{tol}\\,\\}\\cup\\{-1\\} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\leq n} \\] <p><code>tol</code> may also be <code>None</code>, then all coefficients that evaluate to <code>False</code> are trimmed.</p> Notes <ul> <li>Cutting of elements that are <code>abs(v_i)&lt;=tol</code> instead of <code>abs(v_i)&lt;tol</code> to allow cutting of elements that are exactly zero by <code>trim(v, 0)</code> instead of <code>trim(v, sys.float_info.min)</code>.</li> </ul> Source code in <code>vector\\lazy\\utility.py</code> <pre><code>def vecltrim(v, tol=None):\n    r\"\"\"Remove all trailing near zero (`abs(v_i)&lt;=tol`) coefficients.\n\n    $$\n        \\begin{pmatrix}\n            v_0 \\\\\n            \\vdots \\\\\n            v_m\n        \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_{j-1}|&gt;\\text{tol}\\,\\}\\cup\\{-1\\} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\leq n}\n    $$\n\n    `tol` may also be `None`,\n    then all coefficients that evaluate to `False` are trimmed.\n\n    Notes\n    -----\n    - Cutting of elements that are `abs(v_i)&lt;=tol` instead of `abs(v_i)&lt;tol` to\n    allow cutting of elements that are exactly zero by `trim(v, 0)` instead\n    of `trim(v, sys.float_info.min)`.\n    \"\"\"\n    t = []\n    for x in v:\n        t.append(x)\n        if (x if tol is None else abs(x)&gt;tol):\n            yield from t\n            t.clear()\n</code></pre>"},{"location":"lazy/#vector.lazy.utility.veclrshift","title":"<code>veclrshift(v, n, zero=0)</code>","text":"<p>Shift coefficients up.</p> \\[     (v_{i-n})_i \\qquad \\begin{pmatrix}         0 \\\\         \\vdots \\\\         0 \\\\         v_0 \\\\         v_1 \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n} \\] Source code in <code>vector\\lazy\\utility.py</code> <pre><code>def veclrshift(v, n, zero=0):\n    r\"\"\"Shift coefficients up.\n\n    $$\n        (v_{i-n})_i \\qquad \\begin{pmatrix}\n            0 \\\\\n            \\vdots \\\\\n            0 \\\\\n            v_0 \\\\\n            v_1 \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n}\n    $$\n    \"\"\"\n    yield from chain(repeat(zero, n), v)\n</code></pre>"},{"location":"lazy/#vector.lazy.utility.vecllshift","title":"<code>vecllshift(v, n)</code>","text":"<p>Shift coefficients down.</p> \\[     (v_{i+n})_i \\qquad \\begin{pmatrix}         v_n \\\\         v_{n+1} \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}} \\] Source code in <code>vector\\lazy\\utility.py</code> <pre><code>def vecllshift(v, n):\n    r\"\"\"Shift coefficients down.\n\n    $$\n        (v_{i+n})_i \\qquad \\begin{pmatrix}\n            v_n \\\\\n            v_{n+1} \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}}\n    $$\n    \"\"\"\n    yield from islice(v, n, None)\n</code></pre>"},{"location":"lazy/#vector.lazy.hilbert_space","title":"<code>hilbert_space</code>","text":""},{"location":"lazy/#vector.lazy.hilbert_space.try_conjugate","title":"<code>try_conjugate(x)</code>","text":"<p>Return the complex conjugate.</p> \\[     x^* \\qquad \\mathbb{K}\\to\\mathbb{K} \\] <p>Tries to call a method <code>conjugate</code>. If not found, simply returns the element as is.</p> Source code in <code>vector\\lazy\\hilbert_space.py</code> <pre><code>def try_conjugate(x):\n    r\"\"\"Return the complex conjugate.\n\n    $$\n        x^* \\qquad \\mathbb{K}\\to\\mathbb{K}\n    $$\n\n    Tries to call a method `conjugate`.\n    If not found, simply returns the element as is.\n    \"\"\"\n    #try:\n    #    return x.conjugate()\n    #except AttributeError:\n    #    return x\n    #could throw an AttibuteError from somewhere deeper\n    conj = getattr(x, 'conjugate', None)\n    return conj() if callable(conj) else x\n</code></pre>"},{"location":"lazy/#vector.lazy.hilbert_space.veclconj","title":"<code>veclconj(v)</code>","text":"<p>Return the complex conjugate.</p> \\[     \\vec{v}^* \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n \\] <p>Tries to call a method <code>conjugate</code> on each element. If not found, simply keeps the element as is.</p> Source code in <code>vector\\lazy\\hilbert_space.py</code> <pre><code>def veclconj(v):\n    r\"\"\"Return the complex conjugate.\n\n    $$\n        \\vec{v}^* \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n\n    Tries to call a method `conjugate` on each element.\n    If not found, simply keeps the element as is.\n    \"\"\"\n    yield from map(try_conjugate, v)\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space","title":"<code>vector_space</code>","text":""},{"location":"lazy/#vector.lazy.vector_space.veclpos","title":"<code>veclpos(v)</code>","text":"<p>Return the identity.</p> \\[     +\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n \\] Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def veclpos(v):\n    r\"\"\"Return the identity.\n\n    $$\n        +\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    yield from map(pos, v)\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.veclneg","title":"<code>veclneg(v)</code>","text":"<p>Return the negation.</p> \\[     -\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n \\] Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def veclneg(v):\n    r\"\"\"Return the negation.\n\n    $$\n        -\\vec{v} \\qquad \\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    yield from map(neg, v)\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.vecladd","title":"<code>vecladd(*vs)</code>","text":"<p>Return the sum.</p> \\[     \\vec{v}_0+\\vec{v}_1+\\cdots \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i} \\] See also <ul> <li>for sum on a single coefficient: <code>vecladdc</code></li> </ul> Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def vecladd(*vs):\n    r\"\"\"Return the sum.\n\n    $$\n        \\vec{v}_0+\\vec{v}_1+\\cdots \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i}\n    $$\n\n    See also\n    --------\n    - for sum on a single coefficient: [`vecladdc`][vector.lazy.vector_space.vecladdc]\n    \"\"\"\n    yield from map(partial(sum_default, default=MISSING), group_ordinal(*vs))\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.vecladdc","title":"<code>vecladdc(v, c, i=0, zero=0)</code>","text":"<p>Return the sum with a basis vector.</p> \\[     \\vec{v}+c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}} \\] <p>More efficient than <code>vecladd(v, veclbasis(i, c))</code>.</p> See also <ul> <li>for sum on more coefficients: <code>vecladd</code></li> </ul> Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def vecladdc(v, c, i=0, zero=0):\n    r\"\"\"Return the sum with a basis vector.\n\n    $$\n        \\vec{v}+c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}}\n    $$\n\n    More efficient than `vecladd(v, veclbasis(i, c))`.\n\n    See also\n    --------\n    - for sum on more coefficients: [`vecladd`][vector.lazy.vector_space.vecladd]\n    \"\"\"\n    v = iter(v)\n    yield from islice(chain(v, repeat(zero)), i)\n    try:\n        yield next(v) + c\n    except StopIteration:\n        yield +c\n    yield from v\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.veclsub","title":"<code>veclsub(v, w)</code>","text":"<p>Return the difference.</p> \\[     \\vec{v}-\\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{m, n\\}} \\] See also <ul> <li>for difference on a single coefficient: <code>veclsubc</code></li> </ul> Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def veclsub(v, w):\n    r\"\"\"Return the difference.\n\n    $$\n        \\vec{v}-\\vec{w} \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{m, n\\}}\n    $$\n\n    See also\n    --------\n    - for difference on a single coefficient: [`veclsubc`][vector.lazy.vector_space.veclsubc]\n    \"\"\"\n    sentinel = object()\n    for vi, wi in zip_longest(v, w, fillvalue=sentinel):\n        if wi is sentinel:\n            yield vi\n        elif vi is sentinel:\n            yield -wi\n        else:\n            yield vi - wi\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.veclsubc","title":"<code>veclsubc(v, c, i=0, zero=0)</code>","text":"<p>Return the difference with a basis vector.</p> \\[     \\vec{v}-c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}} \\] <p>More efficient than <code>veclsub(v, veclbasis(i, c))</code>.</p> See also <ul> <li>for difference on more coefficients: <code>veclsub</code></li> </ul> Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def veclsubc(v, c, i=0, zero=0):\n    r\"\"\"Return the difference with a basis vector.\n\n    $$\n        \\vec{v}-c\\vec{e}_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}^{\\max\\{n, i+1\\}}\n    $$\n\n    More efficient than `veclsub(v, veclbasis(i, c))`.\n\n    See also\n    --------\n    - for difference on more coefficients: [`veclsub`][vector.lazy.vector_space.veclsub]\n    \"\"\"\n    v = iter(v)\n    yield from islice(chain(v, repeat(zero)), i)\n    try:\n        yield next(v) - c\n    except StopIteration:\n        yield -c\n    yield from v\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.veclmul","title":"<code>veclmul(v, a)</code>","text":"<p>Return the product.</p> \\[     \\vec{v}a \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n \\] Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def veclmul(v, a):\n    r\"\"\"Return the product.\n\n    $$\n        \\vec{v}a \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    yield from map(mul, v, repeat(a))\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.veclrmul","title":"<code>veclrmul(a, v)</code>","text":"<p>Return the product.</p> \\[     a\\vec{v} \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n \\] Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def veclrmul(a, v):\n    r\"\"\"Return the product.\n\n    $$\n        a\\vec{v} \\qquad \\mathbb{K}\\times\\mathbb{K}^n\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    yield from map(mul, repeat(a), v)\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.vecltruediv","title":"<code>vecltruediv(v, a)</code>","text":"<p>Return the true quotient.</p> \\[     \\frac{\\vec{v}}{a} \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n \\] Notes <p>Why called <code>truediv</code> instead of <code>div</code>?</p> <ul> <li><code>div</code> would be more appropriate for an absolute clean mathematical implementation, that doesn't care about the language used. But the package might be used for pure integers/integer arithmetic, so both, <code>truediv</code> and <code>floordiv</code> operations have to be provided, and none should be privileged over the other by getting the universal <code>div</code> name.</li> <li><code>truediv</code>/<code>floordiv</code> is unambiguous, like Python <code>operator</code>s.</li> </ul> Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def vecltruediv(v, a):\n    r\"\"\"Return the true quotient.\n\n    $$\n        \\frac{\\vec{v}}{a} \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\n    $$\n\n    Notes\n    -----\n    Why called `truediv` instead of `div`?\n\n    - `div` would be more appropriate for an absolute clean mathematical\n    implementation, that doesn't care about the language used. But the package\n    might be used for pure integers/integer arithmetic, so both, `truediv`\n    and `floordiv` operations have to be provided, and none should be\n    privileged over the other by getting the universal `div` name.\n    - `truediv`/`floordiv` is unambiguous, like Python `operator`s.\n    \"\"\"\n    yield from map(truediv, v, repeat(a))\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.veclfloordiv","title":"<code>veclfloordiv(v, a)</code>","text":"<p>Return the floor quotient.</p> \\[     \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n \\] Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def veclfloordiv(v, a):\n    r\"\"\"Return the floor quotient.\n\n    $$\n        \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    yield from map(floordiv, v, repeat(a))\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.veclmod","title":"<code>veclmod(v, a)</code>","text":"<p>Return the remainder.</p> \\[     \\vec{v} \\bmod a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n \\] Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def veclmod(v, a):\n    r\"\"\"Return the remainder.\n\n    $$\n        \\vec{v} \\bmod a \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\n    $$\n    \"\"\"\n    yield from map(mod, v, repeat(a))\n</code></pre>"},{"location":"lazy/#vector.lazy.vector_space.vecldivmod","title":"<code>vecldivmod(v, a)</code>","text":"<p>Return the floor quotient and remainder.</p> \\[     \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor, \\ \\left(\\vec{v} \\bmod a\\right) \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\\times\\mathbb{K}^n \\] Source code in <code>vector\\lazy\\vector_space.py</code> <pre><code>def vecldivmod(v, a):\n    r\"\"\"Return the floor quotient and remainder.\n\n    $$\n        \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor, \\ \\left(\\vec{v} \\bmod a\\right) \\qquad \\mathbb{K}^n\\times\\mathbb{K}\\to\\mathbb{K}^n\\times\\mathbb{K}^n\n    $$\n    \"\"\"\n    for vi in v:\n        yield divmod(vi, a)\n</code></pre>"},{"location":"lazy/#vector.lazy.elementwise","title":"<code>elementwise</code>","text":""},{"location":"lazy/#vector.lazy.elementwise.veclhadamard","title":"<code>veclhadamard(*vs)</code>","text":"<p>Return the elementwise product.</p> \\[     \\left((\\vec{v}_0)_i\\cdot(\\vec{v}_1)_i\\cdot\\cdots\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\min_i n_i} \\] Source code in <code>vector\\lazy\\elementwise.py</code> <pre><code>def veclhadamard(*vs):\n    r\"\"\"Return the elementwise product.\n\n    $$\n        \\left((\\vec{v}_0)_i\\cdot(\\vec{v}_1)_i\\cdot\\cdots\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\min_i n_i}\n    $$\n    \"\"\"\n    yield from map(partial(prod_default, default=MISSING), zip(*vs))\n</code></pre>"},{"location":"lazy/#vector.lazy.elementwise.veclhadamardtruediv","title":"<code>veclhadamardtruediv(v, w)</code>","text":"<p>Return the elementwise true quotient.</p> \\[     \\left(\\frac{v_i}{w_i}\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m \\] Source code in <code>vector\\lazy\\elementwise.py</code> <pre><code>def veclhadamardtruediv(v, w):\n    r\"\"\"Return the elementwise true quotient.\n\n    $$\n        \\left(\\frac{v_i}{w_i}\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m\n    $$\n    \"\"\"\n    yield from map(truediv, v, chain(w, exception_generator(ZeroDivisionError)))\n</code></pre>"},{"location":"lazy/#vector.lazy.elementwise.veclhadamardfloordiv","title":"<code>veclhadamardfloordiv(v, w)</code>","text":"<p>Return the elementwise floor quotient.</p> \\[     \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m \\] Source code in <code>vector\\lazy\\elementwise.py</code> <pre><code>def veclhadamardfloordiv(v, w):\n    r\"\"\"Return the elementwise floor quotient.\n\n    $$\n        \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m\n    $$\n    \"\"\"\n    yield from map(floordiv, v, chain(w, exception_generator(ZeroDivisionError)))\n</code></pre>"},{"location":"lazy/#vector.lazy.elementwise.veclhadamardmod","title":"<code>veclhadamardmod(v, w)</code>","text":"<p>Return the elementwise remainder.</p> \\[     \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m \\] Source code in <code>vector\\lazy\\elementwise.py</code> <pre><code>def veclhadamardmod(v, w):\n    r\"\"\"Return the elementwise remainder.\n\n    $$\n        \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^m\\times\\mathbb{K}^n\\to\\mathbb{K}^m\n    $$\n    \"\"\"\n    yield from map(mod, v, chain(w, exception_generator(ZeroDivisionError)))\n</code></pre>"},{"location":"lazy/#vector.lazy.elementwise.veclhadamarddivmod","title":"<code>veclhadamarddivmod(v, w)</code>","text":"<p>Return the elementwise floor quotient and remainder.</p> \\[     \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i, \\ \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^n\\times\\mathbb{K}^m\\to\\mathbb{K}^n\\times\\mathbb{K}^n \\] Source code in <code>vector\\lazy\\elementwise.py</code> <pre><code>def veclhadamarddivmod(v, w):\n    r\"\"\"Return the elementwise floor quotient and remainder.\n\n    $$\n        \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i, \\ \\left(v_i \\bmod w_i\\right)_i \\qquad \\mathbb{K}^n\\times\\mathbb{K}^m\\to\\mathbb{K}^n\\times\\mathbb{K}^n\n    $$\n    \"\"\"\n    yield from map(divmod, v, chain(w, exception_generator(ZeroDivisionError)))\n</code></pre>"},{"location":"lazy/#vector.lazy.elementwise.veclhadamardmin","title":"<code>veclhadamardmin(*vs, key=None)</code>","text":"<p>Return the elementwise minimum.</p> \\[     \\left(\\min((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i} \\] Source code in <code>vector\\lazy\\elementwise.py</code> <pre><code>def veclhadamardmin(*vs, key=None):\n    r\"\"\"Return the elementwise minimum.\n\n    $$\n        \\left(\\min((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i}\n    $$\n    \"\"\"\n    yield from map(partial(min, key=key), group_ordinal(*vs))\n</code></pre>"},{"location":"lazy/#vector.lazy.elementwise.veclhadamardmax","title":"<code>veclhadamardmax(*vs, key=None)</code>","text":"<p>Return the elementwise maximum.</p> \\[     \\left(\\max((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i} \\] Source code in <code>vector\\lazy\\elementwise.py</code> <pre><code>def veclhadamardmax(*vs, key=None):\n    r\"\"\"Return the elementwise maximum.\n\n    $$\n        \\left(\\max((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\qquad \\mathbb{K}^{n_0}\\times\\mathbb{K}^{n_1}\\times\\cdots\\to\\mathbb{K}^{\\max_i n_i}\n    $$\n    \"\"\"\n    yield from map(partial(max, key=key), group_ordinal(*vs))\n</code></pre>"},{"location":"multilinear/","title":"Multilinear","text":"<p>Tensor arithmetic.</p> <p>Prefixed by <code>ten...</code> (tensor).</p> <p>Handle multiaxis vectors, that for example represent multivariate polynomials.</p> <p>Tensors are accepted as <code>numpy.array_like</code> and returned as <code>numpy.ndarray</code>s.</p> <p>Broadcasting happens similar to <code>numpy</code>s broadcasting, but the axes are matched in ascending order instead of descending order, and the arrays don't get stretched but rather padded with zeros.</p>"},{"location":"multilinear/#vector.multilinear.creation","title":"<code>creation</code>","text":""},{"location":"multilinear/#vector.multilinear.creation.tenzero","title":"<code>tenzero = np.zeros((), dtype=object)</code>","text":"<p>Zero tensor.</p> \\[     0 \\qquad \\mathbb{K}^0 \\] <p>An empty array.</p> Notes <p>Why shape <code>(0,)</code> (=one dimensional, zero length) instead of <code>()</code> (zero dimensional)?</p> <p>Shape <code>()</code> would be size one (empty product) and a scalar that could have any nonzero value.</p> <p>Dimensionality of one isn't perfect, but at least its size is then zero and it couldn't be any arbitrary value.</p>"},{"location":"multilinear/#vector.multilinear.creation.tenbasis","title":"<code>tenbasis(i, c=1)</code>","text":"<p>Return a basis tensor.</p> \\[     ce_i \\] <p>Returns a <code>numpy.ndarray</code> with <code>i+1</code> zeros in each direction and a <code>c</code> in the outer corner.</p> Source code in <code>vector\\multilinear\\creation.py</code> <pre><code>def tenbasis(i, c=1):\n    \"\"\"Return a basis tensor.\n\n    $$\n        ce_i\n    $$\n\n    Returns a `numpy.ndarray` with `i+1` zeros in each direction and a `c` in\n    the outer corner.\n    \"\"\"\n    t = np.zeros(np.add(i, 1), dtype=np.result_type(c))\n    t[i] = c #dont unpack i, it might be a scalar\n    return t\n</code></pre>"},{"location":"multilinear/#vector.multilinear.creation.tenrand","title":"<code>tenrand(*d)</code>","text":"<p>Return a random tensor of uniform sampled <code>float</code> coefficients.</p> \\[     t \\sim \\mathcal{U}^d([0, 1[) \\] <p>The coefficients are sampled from a uniform distribution in <code>[0, 1[</code>.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> See also <ul> <li>wraps: <code>numpy.random.rand</code></li> </ul> Source code in <code>vector\\multilinear\\creation.py</code> <pre><code>def tenrand(*d):\n    r\"\"\"Return a random tensor of uniform sampled `float` coefficients.\n\n    $$\n        t \\sim \\mathcal{U}^d([0, 1[)\n    $$\n\n    The coefficients are sampled from a uniform distribution in `[0, 1[`.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n\n    See also\n    --------\n    - wraps: [`numpy.random.rand`](https://numpy.org/doc/stable/reference/generated/numpy.random.rand.html)\n    \"\"\"\n    return np.random.rand(*d)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.creation.tenrandn","title":"<code>tenrandn(*d)</code>","text":"<p>Return a random tensor of normal sampled <code>float</code> coefficients.</p> \\[     t \\sim \\mathcal{N}^d(0, 1) \\] <p>The coefficients are sampled from a normal distribution.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> See also <ul> <li>wraps: <code>numpy.random.randn</code></li> </ul> Source code in <code>vector\\multilinear\\creation.py</code> <pre><code>def tenrandn(*d):\n    r\"\"\"Return a random tensor of normal sampled `float` coefficients.\n\n    $$\n        t \\sim \\mathcal{N}^d(0, 1)\n    $$\n\n    The coefficients are sampled from a normal distribution.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n\n    See also\n    --------\n    - wraps: [`numpy.random.randn`](https://numpy.org/doc/stable/reference/generated/numpy.random.randn.html)\n    \"\"\"\n    return np.random.randn(*d)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.utility","title":"<code>utility</code>","text":""},{"location":"multilinear/#vector.multilinear.utility.tenrank","title":"<code>tenrank(t)</code>","text":"<p>Return the rank.</p> \\[     \\text{rank}\\,t \\] See also <ul> <li>wraps: <code>numpy.ndarray.ndim</code></li> </ul> Source code in <code>vector\\multilinear\\utility.py</code> <pre><code>def tenrank(t):\n    r\"\"\"Return the rank.\n\n    $$\n        \\text{rank}\\,t\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.ndarray.ndim`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.ndim.html)\n    \"\"\"\n    return np.asarray(t).ndim\n</code></pre>"},{"location":"multilinear/#vector.multilinear.utility.tendim","title":"<code>tendim(t)</code>","text":"<p>Return the dimensionalities.</p> \\[     \\dim t \\] See also <ul> <li>wraps: <code>numpy.ndarray.shape</code></li> </ul> Source code in <code>vector\\multilinear\\utility.py</code> <pre><code>def tendim(t):\n    r\"\"\"Return the dimensionalities.\n\n    $$\n        \\dim t\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.ndarray.shape`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.shape.html)\n    \"\"\"\n    return np.asarray(t).shape\n</code></pre>"},{"location":"multilinear/#vector.multilinear.utility.teneq","title":"<code>teneq(s, t)</code>","text":"<p>Return whether two tensors are equal.</p> \\[     s\\overset{?}{=}t \\] Source code in <code>vector\\multilinear\\utility.py</code> <pre><code>def teneq(s, t):\n    r\"\"\"Return whether two tensors are equal.\n\n    $$\n        s\\overset{?}{=}t\n    $$\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"multilinear/#vector.multilinear.utility.tentrim","title":"<code>tentrim(t, tol=None)</code>","text":"<p>Remove all trailing near zero (<code>abs(t_i)&lt;=tol</code>) coefficients.</p> <p><code>tol</code> may also be <code>None</code>, then all coefficients that evaluate to <code>False</code> are trimmed.</p> Notes <ul> <li>Cutting of elements that are <code>abs(t_i)&lt;=tol</code> instead of <code>abs(t_i)&lt;tol</code> to allow cutting of elements that are exactly zero by <code>trim(t, 0)</code> instead of <code>trim(t, sys.float_info.min)</code>.</li> </ul> Source code in <code>vector\\multilinear\\utility.py</code> <pre><code>def tentrim(t, tol=None):\n    \"\"\"Remove all trailing near zero (`abs(t_i)&lt;=tol`) coefficients.\n\n    `tol` may also be `None`,\n    then all coefficients that evaluate to `False` are trimmed.\n\n    Notes\n    -----\n    - Cutting of elements that are `abs(t_i)&lt;=tol` instead of `abs(t_i)&lt;tol` to\n    allow cutting of elements that are exactly zero by `trim(t, 0)` instead\n    of `trim(t, sys.float_info.min)`.\n    \"\"\"\n    t = np.asarray(t)\n    for d in range(t.ndim): #reduce dimension\n        slc_idx = (slice(None),)*d + (-1,) + (...,)\n        slc_drop = (slice(None),)*d + (slice(-1),) + (...,)\n        while t.shape[d]&gt;0 and np.all(np.logical_not(t[slc_idx].astype(bool)) if tol is None else np.abs(t[slc_idx])&lt;=tol):\n            t = t[slc_drop]\n    if t.size == 0:\n        return t.reshape((0,))\n    while t.ndim&gt;1 and t.shape[-1]==1: #reduce rank\n        t = t[..., 0]\n    return t\n</code></pre>"},{"location":"multilinear/#vector.multilinear.utility.tenrshift","title":"<code>tenrshift(t, n)</code>","text":"<p>Shift coefficients up.</p> See also <ul> <li>wraps: <code>numpy.pad</code></li> </ul> Source code in <code>vector\\multilinear\\utility.py</code> <pre><code>def tenrshift(t, n):\n    \"\"\"Shift coefficients up.\n\n    See also\n    --------\n    - wraps: [`numpy.pad`](https://numpy.org/doc/stable/reference/generated/numpy.pad.html)\n    \"\"\"\n    return np.pad(t, tuple((ni, 0) for ni in n))\n</code></pre>"},{"location":"multilinear/#vector.multilinear.utility.tenlshift","title":"<code>tenlshift(t, n)</code>","text":"<p>Shift coefficients down.</p> See also <ul> <li>wraps: <code>numpy.pad</code></li> </ul> Source code in <code>vector\\multilinear\\utility.py</code> <pre><code>def tenlshift(t, n):\n    \"\"\"Shift coefficients down.\n\n    See also\n    --------\n    - wraps: [`numpy.pad`](https://numpy.org/doc/stable/reference/generated/numpy.pad.html)\n    \"\"\"\n    return np.array(t)[*(slice(ni, None) for ni in n)].copy()\n</code></pre>"},{"location":"multilinear/#vector.multilinear.hilbert_space","title":"<code>hilbert_space</code>","text":""},{"location":"multilinear/#vector.multilinear.hilbert_space.tenconj","title":"<code>tenconj(t)</code>","text":"<p>Return the elementwise complex conjugate.</p> \\[     t^* \\] See also <ul> <li>one-dimensional: <code>vecconj</code></li> <li>wraps: <code>numpy.conjugate</code></li> </ul> Source code in <code>vector\\multilinear\\hilbert_space.py</code> <pre><code>def tenconj(t):\n    \"\"\"Return the elementwise complex conjugate.\n\n    $$\n        t^*\n    $$\n\n    See also\n    --------\n    - one-dimensional: [`vecconj`][vector.functional.hilbert_space.vecconj]\n    - wraps: [`numpy.conjugate`](https://numpy.org/doc/stable/reference/generated/numpy.conjugate.html)\n    \"\"\"\n    return np.conjugate(t)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.hilbert_space.tenprod","title":"<code>tenprod(s, t)</code>","text":"<p>Return the tensor product.</p> \\[     s \\otimes t \\] See also <ul> <li>wraps: `numpy.tensordot</li> </ul> Source code in <code>vector\\multilinear\\hilbert_space.py</code> <pre><code>def tenprod(s, t):\n    r\"\"\"Return the tensor product.\n\n    $$\n        s \\otimes t\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.tensordot](https://numpy.org/doc/stable/reference/generated/numpy.tensordot.html)\n    \"\"\"\n    return np.tensordot(s, t, 0)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space","title":"<code>vector_space</code>","text":""},{"location":"multilinear/#vector.multilinear.vector_space.tenpos","title":"<code>tenpos(t)</code>","text":"<p>Return the identity.</p> \\[     +t \\] See also <ul> <li>wraps: <code>numpy.positive</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tenpos(t):\n    \"\"\"Return the identity.\n\n    $$\n        +t\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.positive`](https://numpy.org/doc/stable/reference/generated/numpy.positive.html)\n    \"\"\"\n    return np.positive(t)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tenneg","title":"<code>tenneg(t)</code>","text":"<p>Return the negation.</p> \\[     -t \\] See also <ul> <li>wraps: <code>numpy.negative</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tenneg(t):\n    \"\"\"Return the negation.\n\n    $$\n        -t\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.negative`](https://numpy.org/doc/stable/reference/generated/numpy.negative.html)\n    \"\"\"\n    return np.negative(t)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tenadd","title":"<code>tenadd(*ts)</code>","text":"<p>Return the sum.</p> \\[     t_0 + t_1 + \\cdots \\] See also <ul> <li>for sum on a single coefficient: <code>tenaddc</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tenadd(*ts):\n    r\"\"\"Return the sum.\n\n    $$\n        t_0 + t_1 + \\cdots\n    $$\n\n    See also\n    --------\n    - for sum on a single coefficient: [`tenaddc`][vector.multilinear.vector_space.tenaddc]\n    \"\"\"\n    ts = tuple(map(np.asarray, ts))\n    shape = vechadamardmax(*(t.shape for t in ts))\n    r = np.zeros(shape, dtype=np.result_type(*ts) if ts else object)\n    for t in ts:\n        r[tuple(map(slice, t.shape)) + (0,)*(r.ndim-t.ndim)] += t\n    return r\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tenaddc","title":"<code>tenaddc(t, c, i=(0,))</code>","text":"<p>Return the sum with a basis tensor.</p> \\[     t+ce_i \\] <p>More efficient than <code>tenadd(t, tenbasis(i, c))</code>.</p> See also <ul> <li>for sum on more coefficients: <code>tenadd</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tenaddc(t, c, i=(0,)):\n    \"\"\"Return the sum with a basis tensor.\n\n    $$\n        t+ce_i\n    $$\n\n    More efficient than `tenadd(t, tenbasis(i, c))`.\n\n    See also\n    --------\n    - for sum on more coefficients: [`tenadd`][vector.multilinear.vector_space.tenadd]\n    \"\"\"\n    t = np.asarray(t)\n    while t.ndim &lt; len(i):\n        t = np.expand_dims(t, axis=-1)\n    t = np.pad(t, tuple((0, max(ii-s+1, 0)) for s, ii in zip(t.shape, i)))\n    t[i + (0,)*(len(i)-t.ndim)] += c\n    return t\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tensub","title":"<code>tensub(s, t)</code>","text":"<p>Return the difference.</p> \\[     s - t \\] See also <ul> <li>for difference on a single coefficient: <code>tensubc</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tensub(s, t):\n    \"\"\"Return the difference.\n\n    $$\n        s - t\n    $$\n\n    See also\n    --------\n    - for difference on a single coefficient: [`tensubc`][vector.multilinear.vector_space.tensubc]\n    \"\"\"\n    s, t = np.asarray(s), np.asarray(t)\n    shape = vechadamardmax(s.shape, t.shape)\n    r = np.zeros(shape, dtype=np.result_type(s, t))\n    r[tuple(map(slice, s.shape)) + (0,)*(r.ndim-s.ndim)] = s\n    r[tuple(map(slice, t.shape)) + (0,)*(r.ndim-t.ndim)] -= t\n    return r\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tensubc","title":"<code>tensubc(t, c, i=(0,))</code>","text":"<p>Return the difference with a basis tensor.</p> \\[     t-ce_i \\] <p>More efficient than <code>tensub(t, tenbasis(i, c))</code>.</p> See also <ul> <li>for difference on more coefficients: <code>tensub</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tensubc(t, c, i=(0,)):\n    \"\"\"Return the difference with a basis tensor.\n\n    $$\n        t-ce_i\n    $$\n\n    More efficient than `tensub(t, tenbasis(i, c))`.\n\n    See also\n    --------\n    - for difference on more coefficients: [`tensub`][vector.multilinear.vector_space.tensub]\n    \"\"\"\n    t = np.asarray(t)\n    while t.ndim &lt; len(i):\n        t = np.expand_dims(t, axis=-1)\n    t = np.pad(t, tuple((0, max(ii-s+1, 0)) for s, ii in zip(t.shape, i)))\n    t[i + (0,)*(len(i)-t.ndim)] -= c\n    return t\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tenmul","title":"<code>tenmul(t, a)</code>","text":"<p>Return the product.</p> \\[     ta \\] See also <ul> <li>wraps: <code>numpy.multiply</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tenmul(t, a):\n    \"\"\"Return the product.\n\n    $$\n        ta\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.multiply`](https://numpy.org/doc/stable/reference/generated/numpy.multiply.html)\n    \"\"\"\n    return np.multiply(t, a)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tenrmul","title":"<code>tenrmul(a, t)</code>","text":"<p>Return the product.</p> \\[     at \\] See also <ul> <li>wraps: <code>numpy.multiply</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tenrmul(a, t):\n    \"\"\"Return the product.\n\n    $$\n        at\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.multiply`](https://numpy.org/doc/stable/reference/generated/numpy.multiply.html)\n    \"\"\"\n    return np.multiply(a, t)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tentruediv","title":"<code>tentruediv(t, a)</code>","text":"<p>Return the true quotient.</p> \\[     \\frac{t}{a} \\] Notes <p>Why called <code>truediv</code> instead of <code>div</code>?</p> <ul> <li><code>div</code> would be more appropriate for an absolute clean mathematical implementation, that doesn't care about the language used. But the package might be used for pure integers/integer arithmetic, so both, <code>truediv</code> and <code>floordiv</code> operations have to be provided, and none should be privileged over the other by getting the universal <code>div</code> name.</li> <li><code>truediv</code>/<code>floordiv</code> is unambiguous, like Python <code>operator</code>s.</li> </ul> See also <ul> <li>wraps: <code>numpy.divide</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tentruediv(t, a):\n    r\"\"\"Return the true quotient.\n\n    $$\n        \\frac{t}{a}\n    $$\n\n    Notes\n    -----\n    Why called `truediv` instead of `div`?\n\n    - `div` would be more appropriate for an absolute clean mathematical\n    implementation, that doesn't care about the language used. But the package\n    might be used for pure integers/integer arithmetic, so both, `truediv`\n    and `floordiv` operations have to be provided, and none should be\n    privileged over the other by getting the universal `div` name.\n    - `truediv`/`floordiv` is unambiguous, like Python `operator`s.\n\n    See also\n    --------\n    - wraps: [`numpy.divide`](https://numpy.org/doc/stable/reference/generated/numpy.divide.html)\n    \"\"\"\n    return np.divide(t, a)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tenfloordiv","title":"<code>tenfloordiv(t, a)</code>","text":"<p>Return the floor quotient.</p> \\[     \\left\\lfloor\\frac{t}{a}\\right\\rfloor \\] See also <ul> <li>wraps: <code>numpy.floor_divide</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tenfloordiv(t, a):\n    r\"\"\"Return the floor quotient.\n\n    $$\n        \\left\\lfloor\\frac{t}{a}\\right\\rfloor\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.floor_divide`](https://numpy.org/doc/stable/reference/generated/numpy.floor_divide.html)\n    \"\"\"\n    return np.floor_divide(t, a)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tenmod","title":"<code>tenmod(t, a)</code>","text":"<p>Return the remainder.</p> \\[     t \\bmod a \\] See also <ul> <li>wraps: <code>numpy.mod</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tenmod(t, a):\n    r\"\"\"Return the remainder.\n\n    $$\n        t \\bmod a\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.mod`](https://numpy.org/doc/stable/reference/generated/numpy.mod.html)\n    \"\"\"\n    return np.mod(t, a)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.vector_space.tendivmod","title":"<code>tendivmod(t, a)</code>","text":"<p>Return the floor quotient and remainder</p> \\[     \\left\\lfloor\\frac{t}{a}\\right\\rfloor, \\ \\left(t \\bmod a\\right) \\] See also <ul> <li>wraps: <code>numpy.divmod</code></li> </ul> Source code in <code>vector\\multilinear\\vector_space.py</code> <pre><code>def tendivmod(t, a):\n    r\"\"\"Return the floor quotient and remainder\n\n    $$\n        \\left\\lfloor\\frac{t}{a}\\right\\rfloor, \\ \\left(t \\bmod a\\right)\n    $$\n\n    See also\n    --------\n    - wraps: [`numpy.divmod`](https://numpy.org/doc/stable/reference/generated/numpy.divmod.html)\n    \"\"\"\n    return np.divmod(t, a)\n</code></pre>"},{"location":"multilinear/#vector.multilinear.elementwise","title":"<code>elementwise</code>","text":""},{"location":"multilinear/#vector.multilinear.elementwise.tenhadamard","title":"<code>tenhadamard(*ts)</code>","text":"<p>Return the elementwise product.</p> \\[     \\left((t_0)_i \\cdot (t_1)_i \\cdot \\cdots\\right)_i \\] Source code in <code>vector\\multilinear\\elementwise.py</code> <pre><code>def tenhadamard(*ts):\n    r\"\"\"Return the elementwise product.\n\n    $$\n        \\left((t_0)_i \\cdot (t_1)_i \\cdot \\cdots\\right)_i\n    $$\n    \"\"\"\n    ts = tuple(map(np.asarray, ts))\n    shape = tuple(map(min, zip(*(t.shape for t in ts))))\n    r = np.zeros(shape, dtype=np.result_type(*ts) if ts else object)\n    slc = tuple(map(slice, shape)) + (...,)\n    if ts:\n        r = ts[0][*slc]\n    for t in ts[1:]:\n        r *= t[*slc]\n    return r\n</code></pre>"},{"location":"multilinear/#vector.multilinear.elementwise.tenhadamardtruediv","title":"<code>tenhadamardtruediv(s, t)</code>","text":"<p>Return the elementwise true quotient.</p> \\[     \\left(\\frac{s_i}{t_i}\\right)_i \\] Source code in <code>vector\\multilinear\\elementwise.py</code> <pre><code>def tenhadamardtruediv(s, t):\n    r\"\"\"Return the elementwise true quotient.\n\n    $$\n        \\left(\\frac{s_i}{t_i}\\right)_i\n    $$\n    \"\"\"\n    s, t = np.asarray(s), np.asarray(t)\n    return np.divide(s, t[tuple(map(slice, s.shape)), ...])\n</code></pre>"},{"location":"multilinear/#vector.multilinear.elementwise.tenhadamardfloordiv","title":"<code>tenhadamardfloordiv(s, t)</code>","text":"<p>Return the elementwise floor quotient.</p> \\[     \\left(\\left\\lfloor\\frac{s_i}{t_i}\\right\\rfloor\\right)_i \\] Source code in <code>vector\\multilinear\\elementwise.py</code> <pre><code>def tenhadamardfloordiv(s, t):\n    r\"\"\"Return the elementwise floor quotient.\n\n    $$\n        \\left(\\left\\lfloor\\frac{s_i}{t_i}\\right\\rfloor\\right)_i\n    $$\n    \"\"\"\n    s, t = np.asarray(s), np.asarray(t)\n    return np.floor_divide(s, t[tuple(map(slice, s.shape)), ...])\n</code></pre>"},{"location":"multilinear/#vector.multilinear.elementwise.tenhadamardmod","title":"<code>tenhadamardmod(s, t)</code>","text":"<p>Return the elementwise remainder.</p> \\[     \\left(s_i \\bmod t_i\\right)_i \\] Source code in <code>vector\\multilinear\\elementwise.py</code> <pre><code>def tenhadamardmod(s, t):\n    r\"\"\"Return the elementwise remainder.\n\n    $$\n        \\left(s_i \\bmod t_i\\right)_i\n    $$\n    \"\"\"\n    s, t = np.asarray(s), np.asarray(t)\n    return np.mod(s, t[tuple(map(slice, s.shape)), ...])\n</code></pre>"},{"location":"multilinear/#vector.multilinear.elementwise.tenhadamarddivmod","title":"<code>tenhadamarddivmod(s, t)</code>","text":"<p>Return the elementwise floor quotient and remainder.</p> \\[     \\left(\\left\\lfloor\\frac{s_i}{t_i}\\right\\rfloor\\right)_i, \\ \\left(s_i \\bmod t_i\\right)_i \\] Source code in <code>vector\\multilinear\\elementwise.py</code> <pre><code>def tenhadamarddivmod(s, t):\n    r\"\"\"Return the elementwise floor quotient and remainder.\n\n    $$\n        \\left(\\left\\lfloor\\frac{s_i}{t_i}\\right\\rfloor\\right)_i, \\ \\left(s_i \\bmod t_i\\right)_i\n    $$\n    \"\"\"\n    s, t = np.asarray(s), np.asarray(t)\n    return np.divmod(s, t[tuple(map(slice, s.shape)), ...])\n</code></pre>"},{"location":"multilinear/#vector.multilinear.elementwise.tenhadamardmin","title":"<code>tenhadamardmin(*ts, key=None)</code>","text":"<p>Return the elementwise minimum.</p> \\[     \\left(\\min((t_0)_i, (t_1)_i, \\cdots)\\right)_i \\] Source code in <code>vector\\multilinear\\elementwise.py</code> <pre><code>def tenhadamardmin(*ts, key=None):\n    r\"\"\"Return the elementwise minimum.\n\n    $$\n        \\left(\\min((t_0)_i, (t_1)_i, \\cdots)\\right)_i\n    $$\n    \"\"\"\n    ts = tuple(map(np.asarray, ts))\n    shape = vechadamardmax(*(t.shape for t in ts))\n    r = np.empty(shape, dtype=np.result_type(*ts) if ts else object)\n    filled = np.zeros(shape, dtype=bool)\n    if key is None:\n        for t in ts:\n            slc = tuple(map(slice, t.shape)) + (0,)*(r.ndim-t.ndim)\n            r[slc] = np.where(filled[slc], np.minimum(r[slc], t), t)\n            filled[slc] = True\n    else:\n        kcache = np.empty(shape, dtype=object)\n        for t in ts:\n            slc = tuple(map(slice, t.shape)) + (0,)*(r.ndim-t.ndim)\n            it = np.nditer(\n                [r[slc], t, filled[slc], kcache[slc]],\n                flags = ['refs_ok'],\n                op_flags = [['readwrite'], ['readonly'], ['readonly'], ['readwrite']]\n            )\n            for r_cell, t_cell, is_filled, k_cell in it:\n                t_val = t_cell.item()\n                t_key = key(t_val)\n                if not bool(is_filled):\n                    r_cell[...] = t_val\n                    k_cell[...] = t_key\n                else:\n                    if t_key &lt; k_cell.item():\n                        r_cell[...] = t_val\n                        k_cell[...] = t_key\n            filled[slc] = True\n    r[~filled] = 0\n    return r\n</code></pre>"},{"location":"multilinear/#vector.multilinear.elementwise.tenhadamardmax","title":"<code>tenhadamardmax(*ts, key=None)</code>","text":"<p>Return the elementwise maximum.</p> \\[     \\left(\\min((t_0)_i, (t_1)_i, \\cdots)\\right)_i \\] Source code in <code>vector\\multilinear\\elementwise.py</code> <pre><code>def tenhadamardmax(*ts, key=None):\n    r\"\"\"Return the elementwise maximum.\n\n    $$\n        \\left(\\min((t_0)_i, (t_1)_i, \\cdots)\\right)_i\n    $$\n    \"\"\"\n    ts = tuple(map(np.asarray, ts))\n    shape = vechadamardmax(*(t.shape for t in ts))\n    r = np.empty(shape, dtype=np.result_type(*ts) if ts else object)\n    filled = np.zeros(shape, dtype=bool)\n    if key is None:\n        for t in ts:\n            slc = tuple(map(slice, t.shape)) + (0,)*(r.ndim-t.ndim)\n            r[slc] = np.where(filled[slc], np.maximum(r[slc], t), t)\n            filled[slc] = True\n    else:\n        kcache = np.empty(shape, dtype=object)\n        for t in ts:\n            slc = tuple(map(slice, t.shape)) + (0,)*(r.ndim-t.ndim)\n            it = np.nditer(\n                [r[slc], t, filled[slc], kcache[slc]],\n                flags = ['refs_ok'],\n                op_flags = [['readwrite'], ['readonly'], ['readonly'], ['readwrite']]\n            )\n            for r_cell, t_cell, is_filled, k_cell in it:\n                t_val = t_cell.item()\n                t_key = key(t_val)\n                if not bool(is_filled):\n                    r_cell[...] = t_val\n                    k_cell[...] = t_key\n                else:\n                    if t_key &gt; k_cell.item():\n                        r_cell[...] = t_val\n                        k_cell[...] = t_key\n            filled[slc] = True\n    r[~filled] = 0\n    return r\n</code></pre>"},{"location":"multilinear_sparse/","title":"Multilinear Sparse","text":"<p>Sparse tensor arithmetic.</p> <p>Prefixed by <code>tens...</code> (tensor - sparse).</p> <p>Handle sparse multiaxis tensors, that for example represent multivariate polynomials.</p> <p>Sparse tensors are accepted and returned as <code>dict</code>s whos keys are trimmed (no trailing zeros), non-negative <code>int</code> <code>tuples</code>.</p>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.creation","title":"<code>creation</code>","text":""},{"location":"multilinear_sparse/#vector.multilinear_sparse.creation.tenszero","title":"<code>tenszero = {}</code>","text":"<p>Zero tensor.</p> \\[     0 \\] <p>An empty dictionary: <code>{}</code>.</p>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.creation.tensbasis","title":"<code>tensbasis(i, c=1)</code>","text":"<p>Return a basis tensor.</p> \\[     ce_i \\] <p>Returns a dictionary with a single element <code>i:c</code>.</p> Source code in <code>vector\\multilinear_sparse\\creation.py</code> <pre><code>def tensbasis(i, c=1):\n    \"\"\"Return a basis tensor.\n\n    $$\n        ce_i\n    $$\n\n    Returns a dictionary with a single element `i:c`.\n    \"\"\"\n    return {vectrim(i):c}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.creation.tensrand","title":"<code>tensrand(*d)</code>","text":"<p>Return a random tensor of uniform sampled <code>float</code> coefficients.</p> \\[     t \\sim \\mathcal{U}^d([0, 1[) \\] <p>The coefficients are sampled from a uniform distribution in <code>[0, 1[</code>.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\multilinear_sparse\\creation.py</code> <pre><code>def tensrand(*d):\n    r\"\"\"Return a random tensor of uniform sampled `float` coefficients.\n\n    $$\n        t \\sim \\mathcal{U}^d([0, 1[)\n    $$\n\n    The coefficients are sampled from a uniform distribution in `[0, 1[`.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    return {vectrim(i):random() for i in ndindex(*d)}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.creation.tensrandn","title":"<code>tensrandn(*d, mu=0, sigma=1)</code>","text":"<p>Return a random tensor of normal sampled <code>float</code> coefficients.</p> \\[     t \\sim \\mathcal{N}^d(\\mu, \\sigma) \\] <p>The coefficients are sampled from a normal distribution.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\multilinear_sparse\\creation.py</code> <pre><code>def tensrandn(*d, mu=0, sigma=1):\n    r\"\"\"Return a random tensor of normal sampled `float` coefficients.\n\n    $$\n        t \\sim \\mathcal{N}^d(\\mu, \\sigma)\n    $$\n\n    The coefficients are sampled from a normal distribution.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    return {vectrim(i):gauss(mu, sigma) for i in ndindex(*d)}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.conversion","title":"<code>conversion</code>","text":""},{"location":"multilinear_sparse/#vector.multilinear_sparse.conversion.tenstod","title":"<code>tenstod(t, zero=0)</code>","text":"<p>Return a sparse tensor (<code>dict</code>) as a dense tensor (<code>numpy.ndarray</code>).</p> Source code in <code>vector\\multilinear_sparse\\conversion.py</code> <pre><code>def tenstod(t, zero=0):\n    \"\"\"Return a sparse tensor (`dict`) as a dense tensor (`numpy.ndarray`).\"\"\"\n    r = np.full(tensdim(t), zero, dtype=np.array(t.values).dtype)\n    for i, ti in t.items():\n        r[i] = ti\n    return r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.conversion.tendtos","title":"<code>tendtos(t)</code>","text":"<p>Return a dense tensor (<code>numpy.ndarray</code>) as a sparse tensor (<code>dict</code>).</p> <p>The resulting <code>dict</code> is not trimmed.</p> Source code in <code>vector\\multilinear_sparse\\conversion.py</code> <pre><code>def tendtos(t):\n    \"\"\"Return a dense tensor (`numpy.ndarray`) as a sparse tensor (`dict`).\n\n    The resulting `dict` is not [trimmed][vector.multilinear_sparse.tenstrim].\n    \"\"\"\n    return {vectrim(i):ti for i, ti in np.ndenumerate(t)}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.utility","title":"<code>utility</code>","text":""},{"location":"multilinear_sparse/#vector.multilinear_sparse.utility.tensrank","title":"<code>tensrank(t)</code>","text":"<p>Return the rank.</p> \\[     \\text{rank}\\,t \\] Source code in <code>vector\\multilinear_sparse\\utility.py</code> <pre><code>def tensrank(t):\n    r\"\"\"Return the rank.\n\n    $$\n        \\text{rank}\\,t\n    $$\n    \"\"\"\n    return max(map(len, t.keys()), default=0)\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.utility.tensdim","title":"<code>tensdim(t)</code>","text":"<p>Return the dimensionalities.</p> \\[     \\dim t \\] Source code in <code>vector\\multilinear_sparse\\utility.py</code> <pre><code>def tensdim(t):\n    r\"\"\"Return the dimensionalities.\n\n    $$\n        \\dim t\n    $$\n    \"\"\"\n    return tuple(si+1 for si in vechadamardmax(*t.keys()))\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.utility.tenseq","title":"<code>tenseq(s, t)</code>","text":"<p>Return whether two tensors are equal.</p> \\[     s\\overset{?}{=}t \\] Source code in <code>vector\\multilinear_sparse\\utility.py</code> <pre><code>def tenseq(s, t):\n    r\"\"\"Return whether two tensors are equal.\n\n    $$\n        s\\overset{?}{=}t\n    $$\n    \"\"\"\n    for i in s.keys()&amp;t.keys():\n        if i not in t:\n            if bool(s[i]):\n                return False\n        elif i not in s:\n            if bool(t[i]):\n                return False\n        else:\n            if s[i] != t[i]:\n                return False\n    return True\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.utility.tenstrim","title":"<code>tenstrim(t, tol=None)</code>","text":"<p>Remove all near zero (<code>abs(t_i)&lt;=tol</code>) coefficients.</p> <p><code>tol</code> may also be <code>None</code>, then all coefficients that evaluate to <code>False</code> are trimmed.</p> Notes <ul> <li>Cutting of elements that are <code>abs(t_i)&lt;=tol</code> instead of <code>abs(t_i)&lt;tol</code> to allow cutting of elements that are exactly zero by <code>trim(t, 0)</code> instead of <code>trim(t, sys.float_info.min)</code>.</li> </ul> Source code in <code>vector\\multilinear_sparse\\utility.py</code> <pre><code>def tenstrim(t, tol=None):\n    \"\"\"Remove all near zero (`abs(t_i)&lt;=tol`) coefficients.\n\n    `tol` may also be `None`,\n    then all coefficients that evaluate to `False` are trimmed.\n\n    Notes\n    -----\n    - Cutting of elements that are `abs(t_i)&lt;=tol` instead of `abs(t_i)&lt;tol` to\n    allow cutting of elements that are exactly zero by `trim(t, 0)` instead\n    of `trim(t, sys.float_info.min)`.\n    \"\"\"\n    if tol is None:\n        return {i:ti for i, ti in t.items() if ti}\n    else:\n        return {i:ti for i, ti in t.items() if abs(ti)&gt;tol}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.utility.tensitrim","title":"<code>tensitrim(t, tol=None)</code>","text":"<p>Remove all near zero (<code>abs(t_i)&lt;=tol</code>) coefficients.</p> <p><code>tol</code> may also be <code>None</code>, then all coefficients that evaluate to <code>False</code> are trimmed.</p> Notes <ul> <li>Cutting of elements that are <code>abs(t_i)&lt;=tol</code> instead of <code>abs(t_i)&lt;tol</code> to allow cutting of elements that are exactly zero by <code>trim(t, 0)</code> instead of <code>trim(t, sys.float_info.min)</code>.</li> </ul> Source code in <code>vector\\multilinear_sparse\\utility.py</code> <pre><code>def tensitrim(t, tol=None):\n    \"\"\"Remove all near zero (`abs(t_i)&lt;=tol`) coefficients.\n\n    `tol` may also be `None`,\n    then all coefficients that evaluate to `False` are trimmed.\n\n    Notes\n    -----\n    - Cutting of elements that are `abs(t_i)&lt;=tol` instead of `abs(t_i)&lt;tol` to\n    allow cutting of elements that are exactly zero by `trim(t, 0)` instead\n    of `trim(t, sys.float_info.min)`.\n    \"\"\"\n    if tol is None:\n        indices_to_del = tuple(i for i, ti in t.items() if not ti)\n    else:\n        indices_to_del = tuple(i for i, ti in t.items() if abs(ti)&lt;=tol)\n\n    for i in indices_to_del:\n        del t[i]\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.utility.tensrshift","title":"<code>tensrshift(t, n)</code>","text":"<p>Shift coefficients up.</p> Source code in <code>vector\\multilinear_sparse\\utility.py</code> <pre><code>def tensrshift(t, n):\n    \"\"\"Shift coefficients up.\"\"\"\n    #raw vector addition of indices prolly faster than vecadd\n    return {tuple(starmap(add, zip_longest(i, n, fillvalue=0))):ti\n            for i, ti in t.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.utility.tenslshift","title":"<code>tenslshift(t, n)</code>","text":"<p>Shift coefficients down.</p> Source code in <code>vector\\multilinear_sparse\\utility.py</code> <pre><code>def tenslshift(t, n):\n    \"\"\"Shift coefficients down.\"\"\"\n    r = {}\n    for i, ti in t.items():\n        i = tuple(starmap(sub, zip_longest(i, n, fillvalue=0)))\n        if all(ii&gt;=0 for ii in i):\n            r[i] = ti\n    return r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.hilbert_space","title":"<code>hilbert_space</code>","text":""},{"location":"multilinear_sparse/#vector.multilinear_sparse.hilbert_space.tensconj","title":"<code>tensconj(t)</code>","text":"<p>Return the complex conjugate.</p> \\[     t^* \\] <p>Tries to call a method <code>conjugate</code> on each element. If not found, simply keeps the element as is.</p> Source code in <code>vector\\multilinear_sparse\\hilbert_space.py</code> <pre><code>def tensconj(t):\n    \"\"\"Return the complex conjugate.\n\n    $$\n        t^*\n    $$\n\n    Tries to call a method `conjugate` on each element.\n    If not found, simply keeps the element as is.\n    \"\"\"\n    return {i:try_conjugate(ti) for i, ti in t.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.hilbert_space.tensiconj","title":"<code>tensiconj(t)</code>","text":"<p>Complex conjugate.</p> \\[     t = t^* \\] <p>Tries to call a method <code>conjugate</code> on each element. If not found, simply keeps the element as is.</p> Source code in <code>vector\\multilinear_sparse\\hilbert_space.py</code> <pre><code>def tensiconj(t):\n    \"\"\"Complex conjugate.\n\n    $$\n        t = t^*\n    $$\n\n    Tries to call a method `conjugate` on each element.\n    If not found, simply keeps the element as is.\n    \"\"\"\n    for i, ti in t.values():\n        t[i] = try_conjugate(ti)\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space","title":"<code>vector_space</code>","text":""},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tenspos","title":"<code>tenspos(t)</code>","text":"<p>Return the identity.</p> \\[     +t \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tenspos(t):\n    \"\"\"Return the identity.\n\n    $$\n        +t\n    $$\n    \"\"\"\n    return {i:+ti for i, ti in t.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensipos","title":"<code>tensipos(t)</code>","text":"<p>Apply unary plus.</p> \\[     t = +t \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensipos(t):\n    \"\"\"Apply unary plus.\n\n    $$\n        t = +t\n    $$\n    \"\"\"\n    for i, ti in t.items():\n        t[i] = +ti\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensneg","title":"<code>tensneg(t)</code>","text":"<p>Return the negation.</p> \\[     -t \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensneg(t):\n    \"\"\"Return the negation.\n\n    $$\n        -t\n    $$\n    \"\"\"\n    return {i:-ti for i, ti in t.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensineg","title":"<code>tensineg(t)</code>","text":"<p>Negate.</p> \\[     t = -t \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensineg(t):\n    \"\"\"Negate.\n\n    $$\n        t = -t\n    $$\n    \"\"\"\n    for i, ti in t.items():\n        t[i] = -ti\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensadd","title":"<code>tensadd(*ts)</code>","text":"<p>Return the sum.</p> \\[     t_0 + t_1 + \\cdots \\] See also <ul> <li>for sum on a single coefficient: <code>tensaddc</code></li> </ul> Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensadd(*ts):\n    r\"\"\"Return the sum.\n\n    $$\n        t_0 + t_1 + \\cdots\n    $$\n\n    See also\n    --------\n    - for sum on a single coefficient: [`tensaddc`][vector.multilinear_sparse.vector_space.tensaddc]\n    \"\"\"\n    r = dict(ts[0]) if ts else {}\n    for t in ts[1:]:\n        for i, ti in t.items():\n            if i in r:\n                r[i] += ti\n            else:\n                r[i] = +ti\n    return r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensiadd","title":"<code>tensiadd(s, *ts)</code>","text":"<p>Add.</p> \\[     s += t_0 + t_1 + \\cdots \\] See also <ul> <li>for sum on a single coefficient: <code>tensiaddc</code></li> </ul> Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensiadd(s, *ts):\n    r\"\"\"Add.\n\n    $$\n        s += t_0 + t_1 + \\cdots\n    $$\n\n    See also\n    --------\n    - for sum on a single coefficient: [`tensiaddc`][vector.multilinear_sparse.vector_space.tensiaddc]\n    \"\"\"\n    for t in ts:\n        for i, ti in t.items():\n            if i in s:\n                s[i] += ti\n            else:\n                s[i] = +ti\n    return s\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensaddc","title":"<code>tensaddc(t, c, i=())</code>","text":"<p>Return the sum with a basis tensor.</p> \\[     t + ce_i \\] See also <ul> <li>for sum on more coefficients: <code>tensadd</code></li> </ul> Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensaddc(t, c, i=()):\n    \"\"\"Return the sum with a basis tensor.\n\n    $$\n        t + ce_i\n    $$\n\n    See also\n    --------\n    - for sum on more coefficients: [`tensadd`][vector.multilinear_sparse.vector_space.tensadd]\n    \"\"\"\n    r = dict(t)\n    if i in r:\n        r[i] += c\n    else:\n        r[i] = +c\n    return r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensiaddc","title":"<code>tensiaddc(t, c, i=())</code>","text":"<p>Add a basis tensor.</p> \\[     t += ce_i \\] See also <ul> <li>for sum on more coefficients: <code>tensiadd</code></li> </ul> Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensiaddc(t, c, i=()):\n    \"\"\"Add a basis tensor.\n\n    $$\n        t += ce_i\n    $$\n\n    See also\n    --------\n    - for sum on more coefficients: [`tensiadd`][vector.multilinear_sparse.vector_space.tensiadd]\n    \"\"\"\n    if i in t:\n        t[i] += c\n    else:\n        t[i] = +c\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tenssub","title":"<code>tenssub(s, t)</code>","text":"<p>Return the difference.</p> \\[     s - t \\] See also <ul> <li>for difference on a single coefficient: <code>tenssubc</code></li> </ul> Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tenssub(s, t):\n    \"\"\"Return the difference.\n\n    $$\n        s - t\n    $$\n\n    See also\n    --------\n    - for difference on a single coefficient: [`tenssubc`][vector.multilinear_sparse.vector_space.tenssubc]\n    \"\"\"\n    r = dict(s)\n    for i, ti in t.items():\n        if i in r:\n            r[i] -= ti\n        else:\n            r[i] = -ti\n    return r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensisub","title":"<code>tensisub(s, t)</code>","text":"<p>Subtract.</p> \\[     s -= t \\] See also <ul> <li>for difference on a single coefficient: <code>tensisubc</code></li> </ul> Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensisub(s, t):\n    \"\"\"Subtract.\n\n    $$\n        s -= t\n    $$\n\n    See also\n    --------\n    - for difference on a single coefficient: [`tensisubc`][vector.multilinear_sparse.vector_space.tensisubc]\n    \"\"\"\n    for i, ti in t.items():\n        if i in s:\n            s[i] -= ti\n        else:\n            s[i] = -ti\n    return s\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tenssubc","title":"<code>tenssubc(t, c, i=())</code>","text":"<p>Return the difference with a basis tensor.</p> \\[     t - ce_i \\] See also <ul> <li>for difference on more coefficients: <code>tenssub</code></li> </ul> Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tenssubc(t, c, i=()):\n    \"\"\"Return the difference with a basis tensor.\n\n    $$\n        t - ce_i\n    $$\n\n    See also\n    --------\n    - for difference on more coefficients: [`tenssub`][vector.multilinear_sparse.vector_space.tenssub]\n    \"\"\"\n    r = dict(t)\n    if i in r:\n        r[i] -= c\n    else:\n        r[i] = -c\n    return r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensisubc","title":"<code>tensisubc(t, c, i=())</code>","text":"<p>Subtract a basis tensor.</p> \\[     t -= ce_i \\] See also <ul> <li>for difference on more coefficients: <code>tensisub</code></li> </ul> Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensisubc(t, c, i=()):\n    \"\"\"Subtract a basis tensor.\n\n    $$\n        t -= ce_i\n    $$\n\n    See also\n    --------\n    - for difference on more coefficients: [`tensisub`][vector.multilinear_sparse.vector_space.tensisub]\n    \"\"\"\n    if i in t:\n        t[i] -= c\n    else:\n        t[i] = -c\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensmul","title":"<code>tensmul(t, a)</code>","text":"<p>Return the product.</p> \\[     ta \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensmul(t, a):\n    \"\"\"Return the product.\n\n    $$\n        ta\n    $$\n    \"\"\"\n    return {i:ti*a for i, ti in t.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensrmul","title":"<code>tensrmul(a, t)</code>","text":"<p>Return the product.</p> \\[     at \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensrmul(a, t):\n    \"\"\"Return the product.\n\n    $$\n        at\n    $$\n    \"\"\"\n    return {i:a*ti for i, ti in t.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensimul","title":"<code>tensimul(t, a)</code>","text":"<p>Multiply.</p> \\[     t \\cdot= a \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensimul(t, a):\n    r\"\"\"Multiply.\n\n    $$\n        t \\cdot= a\n    $$\n    \"\"\"\n    for i in t:\n        t[i] *= a\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tenstruediv","title":"<code>tenstruediv(t, a)</code>","text":"<p>Return the true quotient.</p> \\[     \\frac{t}{a} \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tenstruediv(t, a):\n    r\"\"\"Return the true quotient.\n\n    $$\n        \\frac{t}{a}\n    $$\n    \"\"\"\n    return {i:ti/a for i, ti in t.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensitruediv","title":"<code>tensitruediv(t, a)</code>","text":"<p>True divide.</p> \\[     t /= a \\] Notes <p>Why called <code>truediv</code> instead of <code>div</code>?</p> <ul> <li><code>div</code> would be more appropriate for an absolutely clean mathematical implementation, that doesn't care about the language used. But the package might be used for pure integers/integer arithmetic, so both, <code>truediv</code> and <code>floordiv</code> operations have to be provided, and none should be privileged over the other by getting the universal <code>div</code> name.</li> <li><code>truediv</code>/<code>floordiv</code> is unambiguous, like Python <code>operator</code>s.</li> </ul> Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensitruediv(t, a):\n    \"\"\"True divide.\n\n    $$\n        t /= a\n    $$\n\n    Notes\n    -----\n    Why called `truediv` instead of `div`?\n\n    - `div` would be more appropriate for an absolutely clean mathematical\n    implementation, that doesn't care about the language used. But the package\n    might be used for pure integers/integer arithmetic, so both, `truediv`\n    and `floordiv` operations have to be provided, and none should be\n    privileged over the other by getting the universal `div` name.\n    - `truediv`/`floordiv` is unambiguous, like Python `operator`s.\n    \"\"\"\n    for i in t:\n        t[i] /= a\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensfloordiv","title":"<code>tensfloordiv(t, a)</code>","text":"<p>Return the floor quotient.</p> \\[     \\left\\lfloor\\frac{t}{a}\\right\\rfloor \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensfloordiv(t, a):\n    r\"\"\"Return the floor quotient.\n\n    $$\n        \\left\\lfloor\\frac{t}{a}\\right\\rfloor\n    $$\n    \"\"\"\n    return {i:ti//a for i, ti in t.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensifloordiv","title":"<code>tensifloordiv(t, a)</code>","text":"<p>Floor divide.</p> \\[     t //= a \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensifloordiv(t, a):\n    \"\"\"Floor divide.\n\n    $$\n        t //= a\n    $$\n    \"\"\"\n    for i in t:\n        t[i] //= a\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensmod","title":"<code>tensmod(t, a)</code>","text":"<p>Return the remainder.</p> \\[     t \\bmod a \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensmod(t, a):\n    r\"\"\"Return the remainder.\n\n    $$\n        t \\bmod a\n    $$\n    \"\"\"\n    return {i:ti%a for i, ti in t.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensimod","title":"<code>tensimod(t, a)</code>","text":"<p>Mod.</p> \\[     t \\%= a \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensimod(t, a):\n    r\"\"\"Mod.\n\n    $$\n        t \\%= a\n    $$\n    \"\"\"\n    for i in t:\n        t[i] %= a\n    return t\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.vector_space.tensdivmod","title":"<code>tensdivmod(t, a)</code>","text":"<p>Return the floor quotient and remainder.</p> \\[     \\left\\lfloor\\frac{t}{a}\\right\\rfloor, \\ \\left(t \\bmod a\\right) \\] Source code in <code>vector\\multilinear_sparse\\vector_space.py</code> <pre><code>def tensdivmod(t, a):\n    r\"\"\"Return the floor quotient and remainder.\n\n    $$\n        \\left\\lfloor\\frac{t}{a}\\right\\rfloor, \\ \\left(t \\bmod a\\right)\n    $$\n    \"\"\"\n    q, r = {}, {}\n    for i, ti in t.items():\n        q[i], r[i] = divmod(ti, a)\n    return q, r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.elementwise","title":"<code>elementwise</code>","text":""},{"location":"multilinear_sparse/#vector.multilinear_sparse.elementwise.tenshadamard","title":"<code>tenshadamard(*ts)</code>","text":"<p>Return the elementwise product.</p> \\[     \\left((t_0)_i \\cdot (t_1)_i \\cdot \\cdots\\right)_i \\] Source code in <code>vector\\multilinear_sparse\\elementwise.py</code> <pre><code>def tenshadamard(*ts):\n    r\"\"\"Return the elementwise product.\n\n    $$\n        \\left((t_0)_i \\cdot (t_1)_i \\cdot \\cdots\\right)_i\n    $$\n    \"\"\"\n    r = {}\n    if not ts:\n        return r\n    for i in set(ts[0].keys()).intersection(*(t.keys() for t in ts[1:])):\n        r[i] = prod_default((t[i] for t in ts), initial=MISSING, default=MISSING)\n    return r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.elementwise.tenshadamardtruediv","title":"<code>tenshadamardtruediv(s, t)</code>","text":"<p>Return the elementwise true quotient.</p> \\[     \\left(\\frac{s_i}{t_i}\\right)_i \\] Source code in <code>vector\\multilinear_sparse\\elementwise.py</code> <pre><code>def tenshadamardtruediv(s, t):\n    r\"\"\"Return the elementwise true quotient.\n\n    $$\n        \\left(\\frac{s_i}{t_i}\\right)_i\n    $$\n    \"\"\"\n    return {i:si/t[i] for i, si in s.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.elementwise.tenshadamardfloordiv","title":"<code>tenshadamardfloordiv(s, t)</code>","text":"<p>Return the elementwise floor quotient.</p> \\[     \\left(\\left\\lfloor\\frac{s_i}{t_i}\\right\\rfloor\\right)_i \\] Source code in <code>vector\\multilinear_sparse\\elementwise.py</code> <pre><code>def tenshadamardfloordiv(s, t):\n    r\"\"\"Return the elementwise floor quotient.\n\n    $$\n        \\left(\\left\\lfloor\\frac{s_i}{t_i}\\right\\rfloor\\right)_i\n    $$\n    \"\"\"\n    return {i:si//t[i] for i, si in s.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.elementwise.tenshadamardmod","title":"<code>tenshadamardmod(s, t)</code>","text":"<p>Return the elementwise remainder.</p> \\[     \\left(s_i \\bmod t_i\\right)_i \\] Source code in <code>vector\\multilinear_sparse\\elementwise.py</code> <pre><code>def tenshadamardmod(s, t):\n    r\"\"\"Return the elementwise remainder.\n\n    $$\n        \\left(s_i \\bmod t_i\\right)_i\n    $$\n    \"\"\"\n    return {i:si%t[i] for i, si in s.items()}\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.elementwise.tenshadamarddivmod","title":"<code>tenshadamarddivmod(s, t)</code>","text":"<p>Return the elementwise floor quotient and remainder.</p> \\[     \\left(\\left\\lfloor\\frac{s_i}{t_i}\\right\\rfloor\\right)_i, \\ \\left(s_i \\bmod t_i\\right)_i \\] Source code in <code>vector\\multilinear_sparse\\elementwise.py</code> <pre><code>def tenshadamarddivmod(s, t):\n    r\"\"\"Return the elementwise floor quotient and remainder.\n\n    $$\n        \\left(\\left\\lfloor\\frac{s_i}{t_i}\\right\\rfloor\\right)_i, \\ \\left(s_i \\bmod t_i\\right)_i\n    $$\n    \"\"\"\n    q, r = {}, {}\n    for i, ti in t.items():\n        si = s[i]\n        q[i], r[i] = divmod(ti, si)\n    return q, r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.elementwise.tenshadamardmin","title":"<code>tenshadamardmin(*ts, key=None)</code>","text":"<p>Return the elementwise minimum.</p> \\[     \\left(\\min((t_0)_i, (t_1)_i, \\cdots)\\right)_i \\] Source code in <code>vector\\multilinear_sparse\\elementwise.py</code> <pre><code>def tenshadamardmin(*ts, key=None):\n    r\"\"\"Return the elementwise minimum.\n\n    $$\n        \\left(\\min((t_0)_i, (t_1)_i, \\cdots)\\right)_i\n    $$\n    \"\"\"\n    r = {}\n    if not ts:\n        return r\n    for i in set(ts[0].keys()).union(*(t.keys() for t in ts[1:])):\n        r[i] = min(t[i] for t in ts)\n    return r\n</code></pre>"},{"location":"multilinear_sparse/#vector.multilinear_sparse.elementwise.tenshadamardmax","title":"<code>tenshadamardmax(*ts, key=None)</code>","text":"<p>Return the elementwise maximum.</p> \\[     \\left(\\min((t_0)_i, (t_1)_i, \\cdots)\\right)_i \\] Source code in <code>vector\\multilinear_sparse\\elementwise.py</code> <pre><code>def tenshadamardmax(*ts, key=None):\n    r\"\"\"Return the elementwise maximum.\n\n    $$\n        \\left(\\min((t_0)_i, (t_1)_i, \\cdots)\\right)_i\n    $$\n    \"\"\"\n    r = {}\n    if not ts:\n        return r\n    for i in set(ts[0].keys()).union(*(t.keys() for t in ts[1:])):\n        r[i] = max(t[i] for t in ts)\n    return r\n</code></pre>"},{"location":"parallelised/","title":"Parallelised","text":"<pre><code>&gt;&gt;&gt; from vector import vecnpadd\n&gt;&gt;&gt; vecnpadd((1, 2), ((3, 4, 5),\n...                   (6, 7, 8)))\narray([[4, 6, 5],\n       [7, 9, 8]])\n</code></pre> <p>Prefixed by <code>vecnp...</code> (vector numpy).</p> <p><code>numpy</code>-versions of the functions are also provided, to operate on multiple vectors at once. They behave like the ones in <code>numpy.polynomial.polynomial</code>, but also work on 2D-arrays (and all combinations of 1D &amp; 2D arrays) and broadcast to multiple dimensions like the usual <code>numpy</code> operations (but adjust the shapes accordingly).</p> <p><code>vecnpzero</code> is <code>np.array([0])</code> like <code>numpy.polynomial.polynomial.polyzero</code>, not <code>veczero=()</code> (empty tuple, no zero coefficient left) like in the functions and class above.</p> <p>Padding is done with <code>numpy.int64(0)</code>.</p> <p>They return scalars or <code>numpy.ndarray</code>s.</p> <p>Creation routines have a dimension argument <code>d</code>. If left to <code>None</code>, the returned values are 1D, so a single vector. If given, the routines return a 2D-array representing multiple vectors in rows.</p>"},{"location":"parallelised/#creation","title":"Creation","text":""},{"location":"parallelised/#vector.parallelised.vecnpzero","title":"<code>vecnpzero(d=None)</code>","text":"<p>Return <code>d</code> zero vectors.</p> \\[     0^{d\\times 0} \\qquad \\text{or} \\qquad \\begin{pmatrix}         0     \\end{pmatrix}  \\] <p>The returned value is a <code>(d, 1)</code>-array of zeros if <code>d</code> is not <code>None</code> or <code>[0]</code> otherwise.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpzero(d=None):\n    r\"\"\"Return `d` zero vectors.\n\n    $$\n        0^{d\\times 0} \\qquad \\text{or} \\qquad \\begin{pmatrix}\n            0\n        \\end{pmatrix} \n    $$\n\n    The returned value is a `(d, 1)`-array of zeros if `d` is not `None`\n    or `[0]` otherwise.\n    \"\"\"\n    #same dtype as numpy.polynomial.polynomial.polyzero\n    return np.zeros(1 if d is None else (d, 1), dtype=object)\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpbasis","title":"<code>vecnpbasis(i, c=1, d=None)</code>","text":"<p>Return <code>d</code> many <code>i</code>-th basis vectors times <code>c</code>.</p> <p>The returned value is a <code>(d, i+1)</code>-array if <code>d</code> is not <code>None</code> or <code>(i+1,)</code> otherwise.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpbasis(i, c=1, d=None):\n    \"\"\"Return `d` many `i`-th basis vectors times `c`.\n\n    The returned value is a `(d, i+1)`-array if `d` is not `None`\n    or `(i+1,)` otherwise.\n    \"\"\"\n    #choose dtype acc to c\n    v = np.zeros(i+1 if d is None else (d, i+1), dtype=np.dtype(type(c)))\n    v[..., -1] = c #maybe scalar, maybe (d,)-array\n    return v\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnprand","title":"<code>vecnprand(n, d=None)</code>","text":"<p>Return <code>d</code> random vectors of <code>n</code> uniform coefficients in <code>[0, 1[</code>.</p> <p>The returned value is a <code>(d, n)</code>-array if <code>d</code> is not <code>None</code> or <code>(n,)</code> otherwise.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnprand(n, d=None):\n    \"\"\"Return `d` random vectors of `n` uniform coefficients in `[0, 1[`.\n\n    The returned value is a `(d, n)`-array if `d` is not `None`\n    or `(n,)` otherwise.\n    \"\"\"\n    return np.random.rand(*((n,) if d is None else (d, n)))\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnprandn","title":"<code>vecnprandn(n, normed=True, d=None)</code>","text":"<p>Return <code>d</code> random vectors of <code>n</code> normal distributed coefficients.</p> <p>The returned value is a <code>(d, n)</code>-array if <code>d</code> is not <code>None</code> or <code>(n,)</code> otherwise.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnprandn(n, normed=True, d=None):\n    \"\"\"Return `d` random vectors of `n` normal distributed coefficients.\n\n    The returned value is a `(d, n)`-array if `d` is not `None`\n    or `(n,)` otherwise.\n    \"\"\"\n    v = np.random.randn(*((n,) if d is None else (d, n)))\n    return v/np.linalg.norm(v, axis=-1, keepdims=True) if normed else v\n</code></pre>"},{"location":"parallelised/#utility","title":"Utility","text":""},{"location":"parallelised/#vector.parallelised.vecnpdim","title":"<code>vecnpdim(v)</code>","text":"<p>Return the number of allocated dimensions in this vector or vectors.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpdim(v):\n    \"\"\"Return the number of allocated dimensions in this vector or vectors.\"\"\"\n    return np.asarray(v).shape[-1]\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpeq","title":"<code>vecnpeq(v, w)</code>","text":"<p>Return if two vectors are equal.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpeq(v, w):\n    \"\"\"Return if two vectors are equal.\"\"\"\n    v, w = np.asarray(v), np.asarray(w)\n    if v.ndim == w.ndim == 1:\n        return veceq(v, w)\n    return np.array([veceq(v[i] if v.ndim&gt;1 else v, w[i] if w.ndim&gt;1 else w) \\\n            for i in range(v.shape[0] if v.ndim&gt;1 else w.shape[0])])\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnptrim","title":"<code>vecnptrim(v, tol=1e-09)</code>","text":"<p>Remove all trailing near zero (abs(v_i)&lt;=tol) coefficients.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnptrim(v, tol=1e-9):\n    \"\"\"Remove all trailing near zero (abs(v_i)&lt;=tol) coefficients.\"\"\"\n    v = np.asarray(v)\n    #use np.all, because v[...,-1] maybe a scalar (not iterable)\n    while v.shape[-1]&gt;1 and np.all(np.abs(v[...,-1])&lt;=tol):\n        v = v[...,:-1]\n    if v.shape[-1]==1 and np.all(np.abs(v[...,0])&lt;=tol): #leave 'leading' zero\n        v[...,0] = 0\n    return v\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpround","title":"<code>vecnpround(v, ndigits=0)</code>","text":"<p>Wrapper for <code>numpy.round</code>.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpround(v, ndigits=0):\n    \"\"\"Wrapper for `numpy.round`.\"\"\"\n    return np.round(np.asarray(v), ndigits)\n</code></pre>"},{"location":"parallelised/#hilbert-space","title":"Hilbert space","text":""},{"location":"parallelised/#vector.parallelised.vecnpabsq","title":"<code>vecnpabsq(v)</code>","text":"<p>Return the sum of absolute squares of the coefficients.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpabsq(v):\n    \"\"\"Return the sum of absolute squares of the coefficients.\"\"\"\n    return np.sum(np.abs(v)**2, axis=-1)\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpabs","title":"<code>vecnpabs(v)</code>","text":"<p>Return the Euclidean/L2-norm.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpabs(v):\n    \"\"\"Return the Euclidean/L2-norm.\"\"\"\n    return np.linalg.norm(v, axis=-1)\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpdot","title":"<code>vecnpdot(v, w)</code>","text":"<p>Return the inner product of two vectors without conjugation.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpdot(v, w):\n    \"\"\"Return the inner product of two vectors without conjugation.\"\"\"\n    v, w = np.asarray(v), np.asarray(w)\n    shape = tuple(reversed(tuple(\n            map(min, zip(reversed(v.shape), reversed(w.shape))))))\n    return np.sum(v[...,*map(slice, shape)]*w[...,*map(slice, shape)], axis=-1)\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpparallel","title":"<code>vecnpparallel(v, w)</code>","text":"<p>Return if two vectors are parallel.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpparallel(v, w):\n    \"\"\"Return if two vectors are parallel.\"\"\"\n    v, w = np.asarray(v), np.asarray(w)\n    return vecnpabsq(v)*vecnpabsq(w) == vecnpdot(v, w)**2\n</code></pre>"},{"location":"parallelised/#vector-space","title":"Vector space","text":""},{"location":"parallelised/#vector.parallelised.vecnppos","title":"<code>vecnppos(v)</code>","text":"<p>Return the vector with the unary positive operator applied.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnppos(v):\n    \"\"\"Return the vector with the unary positive operator applied.\"\"\"\n    return +np.asarray(v)\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpneg","title":"<code>vecnpneg(v)</code>","text":"<p>Return the vector with the unary negative operator applied.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpneg(v):\n    \"\"\"Return the vector with the unary negative operator applied.\"\"\"\n    return -np.asarray(v)\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpadd","title":"<code>vecnpadd(*vs)</code>","text":"<p>Return the sum of vectors.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpadd(*vs):\n    \"\"\"Return the sum of vectors.\"\"\"\n    if not vs: #empty sum\n        return vecnpzero()\n\n    vs = tuple(map(np.asarray, vs))\n    if not all(v.ndim in {1, 2} for v in vs): #all 1D or 2D\n        raise ValueError\n\n    heights = {vdi for v in vs for vdi in v.shape[:-1]}\n    if len(heights) &gt; 1: #all 2D same height\n        raise ValueError\n\n    r = np.zeros(tuple(heights)+(max(v.shape[-1] for v in vs),),\n            dtype=np.result_type(*vs))\n    for v in vs:\n        r[...,:v.shape[-1]] += v\n    return r\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpsub","title":"<code>vecnpsub(v, w)</code>","text":"<p>Return the difference of two vectors.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpsub(v, w):\n    \"\"\"Return the difference of two vectors.\"\"\"\n    v, w = np.asarray(v), np.asarray(w)\n    if v.ndim not in {1, 2} or w.ndim not in {1, 2}: #1D-1D, 1D-2D, 2D-1D, 2D-2D\n        raise ValueError\n\n    heights = set(v.shape[:-1]) | set(w.shape[:-1])\n    if len(heights) &gt; 1: #both same height if both 2D\n        raise ValueError\n\n    r = np.zeros(tuple(heights)+(max(v.shape[-1], w.shape[-1]),),\n            dtype=np.result_type(v, w))\n    r[...,:v.shape[-1]] += v\n    r[...,:w.shape[-1]] -= w\n    return r\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpmul","title":"<code>vecnpmul(a, v)</code>","text":"<p>Return the product of a scalar and a vector.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpmul(a, v):\n    \"\"\"Return the product of a scalar and a vector.\"\"\"\n    return a * np.asarray(v)\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnptruediv","title":"<code>vecnptruediv(v, a)</code>","text":"<p>Return the true division of a vector and a scalar.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnptruediv(v, a):\n    \"\"\"Return the true division of a vector and a scalar.\"\"\"\n    return np.asarray(v) / a\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpfloordiv","title":"<code>vecnpfloordiv(v, a)</code>","text":"<p>Return the floor division of a vector and a scalar.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpfloordiv(v, a):\n    \"\"\"Return the floor division of a vector and a scalar.\"\"\"\n    return np.asarray(v) // a\n</code></pre>"},{"location":"parallelised/#vector.parallelised.vecnpmod","title":"<code>vecnpmod(v, a)</code>","text":"<p>Return the elementwise mod of a vector and a scalar.</p> Source code in <code>vector\\parallelised.py</code> <pre><code>def vecnpmod(v, a):\n    \"\"\"Return the elementwise mod of a vector and a scalar.\"\"\"\n    return np.asarray(v) % a\n</code></pre>"},{"location":"sparse/","title":"Sparse","text":"<p>Sparse vectors.</p> <pre><code>&gt;&gt;&gt; from vector import vecsadd\n&gt;&gt;&gt; v = {0:1}\n&gt;&gt;&gt; w = {0:2, 3:4}\n&gt;&gt;&gt; vecsadd(a, b)\n{0:3, 3:4}\n</code></pre> <p>Prefixed by <code>vecs...</code> (vector - sparse).</p> <p>All functions accept vectors and return them as <code>dict</code>s (index:coefficient).</p> <p>The functions are type-independent. However, the data types used must support necessary scalar operations. For instance, for vector addition, coefficients must be addable.</p> <p>Index keys are expected to be integers.</p>"},{"location":"sparse/#vector.sparse--docstring-conventions","title":"Docstring conventions","text":"<p>Summary</p> <p>Math notation (vector notation if possible, index notation, domain &amp; codomain)</p> <p>More information (\"More efficient than ...\").</p> Complexity <p>For a vector with \\(n\\) elements there will be - \\(x\\) scalar additions (<code>add</code>), ...</p> Notes <p>Design choices</p> See also <p>Similar functions</p> References <p>Wikipedia, numpy, ...</p>"},{"location":"sparse/#vector.sparse.creation","title":"<code>creation</code>","text":""},{"location":"sparse/#vector.sparse.creation.vecszero","title":"<code>vecszero = {}</code>","text":"<p>Zero vector.</p> \\[     \\vec{0} \\] <p>An empty dictionary: <code>{}</code>.</p>"},{"location":"sparse/#vector.sparse.creation.vecsbasis","title":"<code>vecsbasis(i, c=1)</code>","text":"<p>Return a basis vector.</p> \\[     c\\vec{e}_i \\] <p>Returns a dictionary with a single element <code>i:c</code>.</p> See also <ul> <li>for all basis vectors: <code>vecsbases</code></li> </ul> Source code in <code>vector\\sparse\\creation.py</code> <pre><code>def vecsbasis(i, c=1):\n    r\"\"\"Return a basis vector.\n\n    $$\n        c\\vec{e}_i\n    $$\n\n    Returns a dictionary with a single element `i:c`.\n\n    See also\n    --------\n    - for all basis vectors: [`vecsbases`][vector.sparse.creation.vecsbases]\n    \"\"\"\n    return {i:c}\n</code></pre>"},{"location":"sparse/#vector.sparse.creation.vecsbases","title":"<code>vecsbases(start=0, c=1)</code>","text":"<p>Yield all basis vectors.</p> \\[     \\left(\\vec{e}_n\\right)_{n\\in\\mathbb{N}_{\\geq\\text{start}}} = \\left(\\vec{e}_\\text{start}, \\vec{e}_{\\text{start}+1}, \\dots \\right) \\] See also <ul> <li>for single basis vector: <code>vecsbasis</code></li> </ul> Source code in <code>vector\\sparse\\creation.py</code> <pre><code>def vecsbases(start=0, c=1):\n    r\"\"\"Yield all basis vectors.\n\n    $$\n        \\left(\\vec{e}_n\\right)_{n\\in\\mathbb{N}_{\\geq\\text{start}}} = \\left(\\vec{e}_\\text{start}, \\vec{e}_{\\text{start}+1}, \\dots \\right)\n    $$\n\n    See also\n    --------\n    - for single basis vector: [`vecsbasis`][vector.sparse.creation.vecsbasis]\n    \"\"\"\n    for i in count(start=start):\n        yield vecsbasis(i, c=c)\n</code></pre>"},{"location":"sparse/#vector.sparse.creation.vecsrand","title":"<code>vecsrand(n)</code>","text":"<p>Return a random vector of uniform sampled <code>float</code> coefficients.</p> \\[     \\vec{v}\\sim\\mathcal{U}^n([0, 1[) \\] <p>The coefficients are sampled from a uniform distribution in <code>[0, 1[</code>.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\sparse\\creation.py</code> <pre><code>def vecsrand(n):\n    r\"\"\"Return a random vector of uniform sampled `float` coefficients.\n\n    $$\n        \\vec{v}\\sim\\mathcal{U}^n([0, 1[)\n    $$\n\n    The coefficients are sampled from a uniform distribution in `[0, 1[`.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    return {i:random() for i in range(n)}\n</code></pre>"},{"location":"sparse/#vector.sparse.creation.vecsrandn","title":"<code>vecsrandn(n, normed=True, mu=0, sigma=1, weights=None)</code>","text":"<p>Return a random vector of normal sampled <code>float</code> coefficients.</p> \\[     \\vec{v}\\sim\\mathcal{N}^n(\\mu, \\sigma) \\] <p>The coefficients are sampled from a normal distribution.</p> Notes <p>Naming like <code>numpy.random</code>, because seems more concise (not <code>random</code> &amp; <code>gauss</code> as in the stdlib).</p> Source code in <code>vector\\sparse\\creation.py</code> <pre><code>def vecsrandn(n, normed=True, mu=0, sigma=1, weights=None):\n    r\"\"\"Return a random vector of normal sampled `float` coefficients.\n\n    $$\n        \\vec{v}\\sim\\mathcal{N}^n(\\mu, \\sigma)\n    $$\n\n    The coefficients are sampled from a normal distribution.\n\n    Notes\n    -----\n    Naming like [`numpy.random`](https://numpy.org/doc/stable/reference/random/legacy.html),\n    because seems more concise (not `random` &amp; `gauss` as in the stdlib).\n    \"\"\"\n    v = {i:gauss(mu, sigma) for i in range(n)}\n    return vecstruediv(v, vecsabs(v, weights)) if normed else v\n</code></pre>"},{"location":"sparse/#vector.sparse.conversion","title":"<code>conversion</code>","text":""},{"location":"sparse/#vector.sparse.conversion.vecstod","title":"<code>vecstod(v, zero=0)</code>","text":"<p>Return a sparse vector (<code>dict</code>) as a dense vector (<code>tuple</code>).</p> Source code in <code>vector\\sparse\\conversion.py</code> <pre><code>def vecstod(v, zero=0):\n    \"\"\"Return a sparse vector (`dict`) as a dense vector (`tuple`).\"\"\"\n    d = [zero] * (max(v.keys(), default=-1)+1)\n    for i, vi in v.items():\n        d[i] = vi\n    return tuple(d)\n</code></pre>"},{"location":"sparse/#vector.sparse.conversion.vecdtos","title":"<code>vecdtos(v)</code>","text":"<p>Return a dense vector (<code>tuple</code>) as a sparse vector (<code>dict</code>).</p> <p>The resulting <code>dict</code> is not trimmed.</p> Source code in <code>vector\\sparse\\conversion.py</code> <pre><code>def vecdtos(v):\n    \"\"\"Return a dense vector (`tuple`) as a sparse vector (`dict`).\n\n    The resulting `dict` is not [trimmed][vector.sparse.utility.vecstrim].\n    \"\"\"\n    return {i:vi for i, vi in enumerate(v)}\n</code></pre>"},{"location":"sparse/#vector.sparse.utility","title":"<code>utility</code>","text":""},{"location":"sparse/#vector.sparse.utility.vecslen","title":"<code>vecslen(v)</code>","text":"<p>Return the maximum set index plus one.</p> <p>Doesn't handle trailing zeros, use <code>vecstrim</code> if needed.</p> Source code in <code>vector\\sparse\\utility.py</code> <pre><code>def vecslen(v):\n    \"\"\"Return the maximum set index plus one.\n\n    Doesn't handle trailing zeros, use [`vecstrim`][vector.sparse.utility.vecstrim]\n    if needed.\n    \"\"\"\n    return max(v.keys(), default=0)\n</code></pre>"},{"location":"sparse/#vector.sparse.utility.vecseq","title":"<code>vecseq(v, w)</code>","text":"<p>Return whether two vectors are equal.</p> \\[     \\vec{v} \\overset{?}{=} \\vec{w} \\] Complexity <p>For two vectors of lengths \\(n\\) &amp; \\(m\\) there will be at most</p> <ul> <li>\\(\\min\\{n, m\\}\\) scalar comparisons (<code>eq</code>) &amp;</li> <li>\\(|n-m|\\) scalar boolean evaluations (<code>bool</code>).</li> </ul> Source code in <code>vector\\sparse\\utility.py</code> <pre><code>def vecseq(v, w):\n    r\"\"\"Return whether two vectors are equal.\n\n    $$\n        \\vec{v} \\overset{?}{=} \\vec{w}\n    $$\n\n    Complexity\n    ----------\n    For two vectors of lengths $n$ &amp; $m$ there will be at most\n\n    - $\\min\\{n, m\\}$ scalar comparisons (`eq`) &amp;\n    - $|n-m|$ scalar boolean evaluations (`bool`).\n    \"\"\"\n    for k in v.keys() | w.keys():\n        if k not in w:\n            if bool(v[k]):\n                return False\n        elif k not in v:\n            if bool(w[k]):\n                return False\n        else:\n            if not v[k]==w[k]:\n                return False\n    return True\n</code></pre>"},{"location":"sparse/#vector.sparse.utility.vecstrim","title":"<code>vecstrim(v, tol=None)</code>","text":"<p>Remove all near zero (<code>abs(v_i)&lt;=tol</code>) coefficients.</p> \\[     \\begin{pmatrix}         v_0 \\\\         \\vdots \\\\         v_m     \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_j|&gt;\\text{tol}\\,\\}\\cup\\{-1\\} \\] <p><code>tol</code> may also be <code>None</code>, then all coefficients that evaluate to <code>False</code> are trimmed.</p> Complexity <p>For a vector of \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar absolute evaluations (<code>abs</code>) &amp;</li> <li>\\(n\\) scalar comparisons (<code>gt</code>).</li> </ul> Notes <ul> <li>Cutting of elements that are <code>abs(v_i)&lt;=tol</code> instead of <code>abs(v_i)&lt;tol</code> to allow cutting of elements that are exactly zero by <code>trim(v, 0)</code> instead of <code>trim(v, sys.float_info.min)</code>.</li> </ul> Source code in <code>vector\\sparse\\utility.py</code> <pre><code>def vecstrim(v, tol=None):\n    r\"\"\"Remove all near zero (`abs(v_i)&lt;=tol`) coefficients.\n\n    $$\n        \\begin{pmatrix}\n            v_0 \\\\\n            \\vdots \\\\\n            v_m\n        \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_j|&gt;\\text{tol}\\,\\}\\cup\\{-1\\}\n    $$\n\n    `tol` may also be `None`,\n    then all coefficients that evaluate to `False` are trimmed.\n\n    Complexity\n    ----------\n    For a vector of $n$ elements there will be\n\n    - $n$ scalar absolute evaluations (`abs`) &amp;\n    - $n$ scalar comparisons (`gt`).\n\n    Notes\n    -----\n    - Cutting of elements that are `abs(v_i)&lt;=tol` instead of `abs(v_i)&lt;tol` to\n    allow cutting of elements that are exactly zero by `trim(v, 0)` instead\n    of `trim(v, sys.float_info.min)`.\n    \"\"\"\n    if tol is None:\n        return {i:vi for i, vi in v.items() if vi}\n    else:\n        return {i:vi for i, vi in v.items() if abs(vi)&gt;tol}\n</code></pre>"},{"location":"sparse/#vector.sparse.utility.vecsitrim","title":"<code>vecsitrim(v, tol=None)</code>","text":"<p>Remove all near zero (<code>abs(v_i)&lt;=tol</code>) coefficients.</p> \\[     \\begin{pmatrix}         v_0 \\\\         \\vdots \\\\         v_m     \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_j|&gt;\\text{tol}\\,\\}\\cup\\{-1\\} \\] <p><code>tol</code> may also be <code>None</code>, then all coefficients that evaluate to <code>False</code> are trimmed.</p> Complexity <p>For a vector of \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar absolute evaluations (<code>abs</code>) &amp;</li> <li>\\(n\\) scalar comparisons (<code>gt</code>).</li> </ul> Notes <ul> <li>Cutting of elements that are <code>abs(v_i)&lt;=tol</code> instead of <code>abs(v_i)&lt;tol</code> to allow cutting of elements that are exactly zero by <code>trim(v, 0)</code> instead of <code>trim(v, sys.float_info.min)</code>.</li> </ul> Source code in <code>vector\\sparse\\utility.py</code> <pre><code>def vecsitrim(v, tol=None):\n    r\"\"\"Remove all near zero (`abs(v_i)&lt;=tol`) coefficients.\n\n    $$\n        \\begin{pmatrix}\n            v_0 \\\\\n            \\vdots \\\\\n            v_m\n        \\end{pmatrix} \\ \\text{where} \\ m=\\max\\{\\, j\\mid |v_j|&gt;\\text{tol}\\,\\}\\cup\\{-1\\}\n    $$\n\n    `tol` may also be `None`,\n    then all coefficients that evaluate to `False` are trimmed.\n\n    Complexity\n    ----------\n    For a vector of $n$ elements there will be\n\n    - $n$ scalar absolute evaluations (`abs`) &amp;\n    - $n$ scalar comparisons (`gt`).\n\n    Notes\n    -----\n    - Cutting of elements that are `abs(v_i)&lt;=tol` instead of `abs(v_i)&lt;tol` to\n    allow cutting of elements that are exactly zero by `trim(v, 0)` instead\n    of `trim(v, sys.float_info.min)`.\n    \"\"\"\n    if tol is None:\n        indices_to_del = tuple(i for i, vi in v.items() if not vi)\n    else:\n        indices_to_del = tuple(i for i, vi in v.items() if abs(vi)&lt;=tol)\n\n    for i in indices_to_del:\n        del v[i]\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.utility.vecsrshift","title":"<code>vecsrshift(v, n)</code>","text":"<p>Shift coefficients up.</p> \\[     (v_{i-n})_i \\qquad \\begin{pmatrix}         0 \\\\         \\vdots \\\\         0 \\\\         v_0 \\\\         v_1 \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n} \\] Source code in <code>vector\\sparse\\utility.py</code> <pre><code>def vecsrshift(v, n):\n    r\"\"\"Shift coefficients up.\n\n    $$\n        (v_{i-n})_i \\qquad \\begin{pmatrix}\n            0 \\\\\n            \\vdots \\\\\n            0 \\\\\n            v_0 \\\\\n            v_1 \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n}\n    $$\n    \"\"\"\n    return {i+n:vi for i, vi in v.items()}\n</code></pre>"},{"location":"sparse/#vector.sparse.utility.vecsirshift","title":"<code>vecsirshift(v, n)</code>","text":"<p>Shift coefficients up.</p> \\[     (v_{i-n})_i \\qquad \\begin{pmatrix}         0 \\\\         \\vdots \\\\         0 \\\\         v_0 \\\\         v_1 \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n} \\] Source code in <code>vector\\sparse\\utility.py</code> <pre><code>def vecsirshift(v, n):\n    r\"\"\"Shift coefficients up.\n\n    $$\n        (v_{i-n})_i \\qquad \\begin{pmatrix}\n            0 \\\\\n            \\vdots \\\\\n            0 \\\\\n            v_0 \\\\\n            v_1 \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{m+n}\n    $$\n    \"\"\"\n    for i in sorted(v.keys(), reverse=True):\n        v[i+n] = v.pop(i)\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.utility.vecslshift","title":"<code>vecslshift(v, n)</code>","text":"<p>Shift coefficients down.</p> \\[     (v_{i+n})_i \\qquad \\begin{pmatrix}         v_n \\\\         v_{n+1} \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}} \\] Source code in <code>vector\\sparse\\utility.py</code> <pre><code>def vecslshift(v, n):\n    r\"\"\"Shift coefficients down.\n\n    $$\n        (v_{i+n})_i \\qquad \\begin{pmatrix}\n            v_n \\\\\n            v_{n+1} \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}}\n    $$\n    \"\"\"\n    return {i-n:vi for i, vi in v.items() if i-n&gt;=0}\n</code></pre>"},{"location":"sparse/#vector.sparse.utility.vecsilshift","title":"<code>vecsilshift(v, n)</code>","text":"<p>Shift coefficients down.</p> \\[     (v_{i+n})_i \\qquad \\begin{pmatrix}         v_n \\\\         v_{n+1} \\\\         \\vdots     \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}} \\] Source code in <code>vector\\sparse\\utility.py</code> <pre><code>def vecsilshift(v, n):\n    r\"\"\"Shift coefficients down.\n\n    $$\n        (v_{i+n})_i \\qquad \\begin{pmatrix}\n            v_n \\\\\n            v_{n+1} \\\\\n            \\vdots\n        \\end{pmatrix} \\qquad \\mathbb{K}^m\\to\\mathbb{K}^{\\max\\{m-n, 0\\}}\n    $$\n    \"\"\"\n    for i in sorted(v.keys()):\n        vi = v.pop(i)\n        if i-n &gt;= 0:\n            v[i-n] = vi\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.hilbert_space","title":"<code>hilbert_space</code>","text":""},{"location":"sparse/#vector.sparse.hilbert_space.vecsconj","title":"<code>vecsconj(v)</code>","text":"<p>Return the complex conjugate.</p> \\[     \\vec{v}^* \\] <p>Tries to call a method <code>conjugate</code> on each element. If not found, simply keeps the element as is.</p> Complexity <p>For a vector of \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar conjugations.</li> </ul> Source code in <code>vector\\sparse\\hilbert_space.py</code> <pre><code>def vecsconj(v):\n    r\"\"\"Return the complex conjugate.\n\n    $$\n        \\vec{v}^*\n    $$\n\n    Tries to call a method `conjugate` on each element.\n    If not found, simply keeps the element as is.\n\n    Complexity\n    ----------\n    For a vector of $n$ elements there will be\n\n    - $n$ scalar conjugations.\n    \"\"\"\n    return {i:try_conjugate(vi) for i, vi in v.items()}\n</code></pre>"},{"location":"sparse/#vector.sparse.hilbert_space.vecsiconj","title":"<code>vecsiconj(v)</code>","text":"<p>Complex conjugate.</p> \\[     \\vec{v} = \\vec{v}^* \\] <p>Tries to call a method <code>conjugate</code> on each element. If not found, simply keeps the element as is.</p> Complexity <p>For a vector of \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar conjugations.</li> </ul> Source code in <code>vector\\sparse\\hilbert_space.py</code> <pre><code>def vecsiconj(v):\n    r\"\"\"Complex conjugate.\n\n    $$\n        \\vec{v} = \\vec{v}^*\n    $$\n\n    Tries to call a method `conjugate` on each element.\n    If not found, simply keeps the element as is.\n\n    Complexity\n    ----------\n    For a vector of $n$ elements there will be\n\n    - $n$ scalar conjugations.\n    \"\"\"\n    for i, vi in v.items():\n        v[i] = try_conjugate(vi)\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.hilbert_space.vecsabs","title":"<code>vecsabs(v, weights=None, conjugate=False, zero=0)</code>","text":"<p>Return the Euclidean/\\(\\ell_{\\mathbb{N}_0}^2\\)-norm.</p> \\[     ||\\vec{v}||_{\\ell_{\\mathbb{N}_0}^2}=\\sqrt{\\sum_iv_i^{(*)}v_i\\omega_i} \\] <p>Returns the square root of <code>vecsabsq</code>.</p> Complexity <p>For a vector of \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar conjugations (<code>conjugate</code>) (if selected),</li> <li>\\(n\\)/\\(2n\\) scalar multiplications (<code>mul</code>) without/with weights,</li> <li>\\(\\begin{cases}n-1&amp;n\\ge1\\\\0&amp;n\\le1\\end{cases}\\) scalar additions (<code>add</code>) &amp;</li> <li>one <code>^0.5</code> call.</li> </ul> See also <ul> <li>squared version without square root: <code>vecsabsq</code></li> </ul> Source code in <code>vector\\sparse\\hilbert_space.py</code> <pre><code>def vecsabs(v, weights=None, conjugate=False, zero=0):\n    r\"\"\"Return the Euclidean/$\\ell_{\\mathbb{N}_0}^2$-norm.\n\n    $$\n        ||\\vec{v}||_{\\ell_{\\mathbb{N}_0}^2}=\\sqrt{\\sum_iv_i^{(*)}v_i\\omega_i}\n    $$\n\n    Returns the square root of [`vecsabsq`][vector.sparse.hilbert_space.vecsabsq].\n\n    Complexity\n    ----------\n    For a vector of $n$ elements there will be\n\n    - $n$ scalar conjugations (`conjugate`) (if selected),\n    - $n$/$2n$ scalar multiplications (`mul`) without/with weights,\n    - $\\begin{cases}n-1&amp;n\\ge1\\\\0&amp;n\\le1\\end{cases}$ scalar additions (`add`) &amp;\n    - one `^0.5` call.\n\n    See also\n    --------\n    - squared version without square root: [`vecsabsq`][vector.sparse.hilbert_space.vecsabsq]\n    \"\"\"\n    return vecsabsq(v, weights=weights, conjugate=conjugate, zero=zero)**0.5\n</code></pre>"},{"location":"sparse/#vector.sparse.hilbert_space.vecsabsq","title":"<code>vecsabsq(v, weights=None, conjugate=False, zero=0)</code>","text":"<p>Return the sum of absolute squares.</p> \\[     ||\\vec{v}||_{\\ell_{\\mathbb{N}_0}^2}^2=\\sum_iv_i^{(*)}v_i\\omega_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}_0^+ \\] Notes <p>Reasons why it exists:</p> <ul> <li>Occurs in math.</li> <li>Most importantly: type independent because it doesn't use <code>sqrt</code>.</li> </ul> References <ul> <li>https://docs.python.org/3/library/itertools.html#itertools-recipes: <code>sum_of_squares</code></li> </ul> Source code in <code>vector\\sparse\\hilbert_space.py</code> <pre><code>def vecsabsq(v, weights=None, conjugate=False, zero=0):\n    r\"\"\"Return the sum of absolute squares.\n\n    $$\n        ||\\vec{v}||_{\\ell_{\\mathbb{N}_0}^2}^2=\\sum_iv_i^{(*)}v_i\\omega_i \\qquad \\mathbb{K}^n\\to\\mathbb{K}_0^+\n    $$\n\n    Notes\n    -----\n    Reasons why it exists:\n\n    - Occurs in math.\n    - Most importantly: type independent because it doesn't use `sqrt`.\n\n    References\n    ----------\n    - &lt;https://docs.python.org/3/library/itertools.html#itertools-recipes&gt;: `sum_of_squares`\n    \"\"\"\n    if weights is None:\n        if not conjugate:\n            return sumprod_default(v.values(), v.values(), default=zero)\n        else:\n            return sumprod_default(map(try_conjugate, v.values()), v.values(), default=zero)\n    else:\n        if not conjugate:\n            return sum_default((vi*vi*weights[i] for i, vi in v.items()), default=zero)\n        else:\n            return sum_default((try_conjugate(vi)*vi*weights[i] for i, vi in v.items()), default=zero)\n</code></pre>"},{"location":"sparse/#vector.sparse.hilbert_space.vecsdot","title":"<code>vecsdot(v, w, weights=None, conjugate=False, zero=0)</code>","text":"<p>Return the inner product.</p> \\[     \\left&lt;\\vec{v}\\mid\\vec{w}\\right&gt;_{\\ell_{\\mathbb{N}_0}^2}=\\sum_iv_i^{(*)}w_i\\omega_i \\] Source code in <code>vector\\sparse\\hilbert_space.py</code> <pre><code>def vecsdot(v, w, weights=None, conjugate=False, zero=0):\n    r\"\"\"Return the inner product.\n\n    $$\n        \\left&lt;\\vec{v}\\mid\\vec{w}\\right&gt;_{\\ell_{\\mathbb{N}_0}^2}=\\sum_iv_i^{(*)}w_i\\omega_i\n    $$\n    \"\"\"\n    if weights is None:\n        if not conjugate:\n            return sum_default((v[k]*w[k] for k in v.keys()&amp;w.keys()), default=zero)\n        else:\n            return sum_default((try_conjugate(v[k])*w[k] for k in v.keys()&amp;w.keys()), default=zero)\n    else:\n        if not conjugate:\n            return sum_default((v[k]*w[k]*weights[k] for k in v.keys()&amp;w.keys()), default=zero)\n        else:\n            return sum_default((try_conjugate(v[k])*w[k]*weights[k] for k in v.keys()&amp;w.keys()), default=zero)\n</code></pre>"},{"location":"sparse/#vector.sparse.hilbert_space.vecsparallel","title":"<code>vecsparallel(v, w, weights=None, conjugate=False, zero=0)</code>","text":"<p>Return if two vectors are parallel.</p> \\[     \\vec{v}\\parallel\\vec{w} \\qquad ||\\vec{v}||\\,||\\vec{w}|| \\overset{?}{=} |\\vec{v}\\vec{w}|^2 \\] Source code in <code>vector\\sparse\\hilbert_space.py</code> <pre><code>def vecsparallel(v, w, weights=None, conjugate=False, zero=0):\n    r\"\"\"Return if two vectors are parallel.\n\n    $$\n        \\vec{v}\\parallel\\vec{w} \\qquad ||\\vec{v}||\\,||\\vec{w}|| \\overset{?}{=} |\\vec{v}\\vec{w}|^2\n    $$\n    \"\"\"\n    vv = vecsabsq(v, weights=weights, conjugate=conjugate, zero=zero)\n    ww = vecsabsq(w, weights=weights, conjugate=conjugate, zero=zero)\n    vw = vecsdot(v, w, weights=weights, conjugate=conjugate, zero=zero)\n    return vv * ww == (try_conjugate(vw) if conjugate else vw) * vw\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space","title":"<code>vector_space</code>","text":""},{"location":"sparse/#vector.sparse.vector_space.vecspos","title":"<code>vecspos(v)</code>","text":"<p>Return the identity.</p> \\[     +\\vec{v} \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar unary plus operations (<code>pos</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecspos(v):\n    r\"\"\"Return the identity.\n\n    $$\n        +\\vec{v}\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar unary plus operations (`pos`).\n    \"\"\"\n    return {i:+vi for i, vi in v.items()}\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsipos","title":"<code>vecsipos(v)</code>","text":"<p>Apply unary plus.</p> \\[     \\vec{v} = +\\vec{v} \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar unary plus operations (<code>pos</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsipos(v):\n    r\"\"\"Apply unary plus.\n\n    $$\n        \\vec{v} = +\\vec{v}\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar unary plus operations (`pos`).\n    \"\"\"\n    for i, vi in v.items():\n        v[i] = +vi\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsneg","title":"<code>vecsneg(v)</code>","text":"<p>Return the negation.</p> \\[     -\\vec{v} \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar negations (<code>neg</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsneg(v):\n    r\"\"\"Return the negation.\n\n    $$\n        -\\vec{v}\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar negations (`neg`).\n    \"\"\"\n    return {i:-vi for i, vi in v.items()}\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsineg","title":"<code>vecsineg(v)</code>","text":"<p>Negate.</p> \\[     \\vec{v} = -\\vec{v} \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar negations (<code>neg</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsineg(v):\n    r\"\"\"Negate.\n\n    $$\n        \\vec{v} = -\\vec{v}\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar negations (`neg`).\n    \"\"\"\n    for i, vi in v.items():\n        v[i] = -vi\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsadd","title":"<code>vecsadd(*vs)</code>","text":"<p>Return the sum.</p> \\[     \\vec{v}_0+\\vec{v}_1+\\cdots \\] Complexity <p>For two vectors with \\(n\\) &amp; \\(m\\) elements there will be</p> <ul> <li>\\(\\min\\{n, m\\}\\) scalar additions (<code>iadd</code>) &amp;</li> <li>\\(\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}\\) unary plus operations (<code>pos</code>).</li> </ul> See also <ul> <li>for sum on a single coefficient: <code>vecsaddc</code></li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsadd(*vs):\n    r\"\"\"Return the sum.\n\n    $$\n        \\vec{v}_0+\\vec{v}_1+\\cdots\n    $$\n\n    Complexity\n    ----------\n    For two vectors with $n$ &amp; $m$ elements there will be\n\n    - $\\min\\{n, m\\}$ scalar additions (`iadd`) &amp;\n    - $\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}$ unary plus operations (`pos`).\n\n    See also\n    --------\n    - for sum on a single coefficient: [`vecsaddc`][vector.sparse.vector_space.vecsaddc]\n    \"\"\"\n    r = dict(vs[0]) if vs else {}\n    for v in vs[1:]:\n        for i, vi in v.items():\n            if i in r:\n                r[i] += vi\n            else:\n                r[i] = +vi\n    return r\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsiadd","title":"<code>vecsiadd(v, *ws)</code>","text":"<p>Add.</p> \\[     \\vec{v} += \\vec{w}_0+\\vec{w}_1+\\cdots \\] Complexity <p>For two vectors with \\(n\\) &amp; \\(m\\) elements there will be</p> <ul> <li>\\(\\min\\{n, m\\}\\) scalar additions (<code>iadd</code>) &amp;</li> <li>\\(\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}\\) unary plus operations (<code>pos</code>).</li> </ul> See also <ul> <li>for sum on a single coefficient: <code>vecsiaddc</code></li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsiadd(v, *ws):\n    r\"\"\"Add.\n\n    $$\n        \\vec{v} += \\vec{w}_0+\\vec{w}_1+\\cdots\n    $$\n\n    Complexity\n    ----------\n    For two vectors with $n$ &amp; $m$ elements there will be\n\n    - $\\min\\{n, m\\}$ scalar additions (`iadd`) &amp;\n    - $\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}$ unary plus operations (`pos`).\n\n    See also\n    --------\n    - for sum on a single coefficient: [`vecsiaddc`][vector.sparse.vector_space.vecsiaddc]\n    \"\"\"\n    for w in ws:\n        for i, wi in w.items():\n            if i in v:\n                v[i] += wi\n            else:\n                v[i] = +wi\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsaddc","title":"<code>vecsaddc(v, c, i=0)</code>","text":"<p>Return the sum with a basis vector.</p> \\[     \\vec{v}+c\\vec{e}_i \\] Complexity <p>There will be</p> <ul> <li>one scalar addition (<code>iadd</code>) if \\(i\\in\\vec{v}\\) or</li> <li>one unary plus operation (<code>pos</code>) otherwise.</li> </ul> See also <ul> <li>for sum on more coefficients: <code>vecsadd</code></li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsaddc(v, c, i=0):\n    r\"\"\"Return the sum with a basis vector.\n\n    $$\n        \\vec{v}+c\\vec{e}_i\n    $$\n\n    Complexity\n    ----------\n    There will be\n\n    - one scalar addition (`iadd`) if $i\\in\\vec{v}$ or\n    - one unary plus operation (`pos`) otherwise.\n\n    See also\n    --------\n    - for sum on more coefficients: [`vecsadd`][vector.sparse.vector_space.vecsadd]\n    \"\"\"\n    r = dict(v)\n    if i in r:\n        r[i] += c\n    else:\n        r[i] = +c\n    return r\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsiaddc","title":"<code>vecsiaddc(v, c, i=0)</code>","text":"<p>Add a basis vector.</p> \\[     \\vec{v} += c\\vec{e}_i \\] Complexity <p>There will be</p> <ul> <li>one scalar addition (<code>iadd</code>) if \\(i\\in\\vec{v}\\) or</li> <li>one unary plus operation (<code>pos</code>) otherwise.</li> </ul> See also <ul> <li>for sum on more coefficients: <code>vecsiadd</code></li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsiaddc(v, c, i=0):\n    r\"\"\"Add a basis vector.\n\n    $$\n        \\vec{v} += c\\vec{e}_i\n    $$\n\n    Complexity\n    ----------\n    There will be\n\n    - one scalar addition (`iadd`) if $i\\in\\vec{v}$ or\n    - one unary plus operation (`pos`) otherwise.\n\n    See also\n    --------\n    - for sum on more coefficients: [`vecsiadd`][vector.sparse.vector_space.vecsiadd]\n    \"\"\"\n    if i in v:\n        v[i] += c\n    else:\n        v[i] = +c\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecssub","title":"<code>vecssub(v, w)</code>","text":"<p>Return the difference.</p> \\[     \\vec{v}-\\vec{w} \\] Complexity <p>For two vectors with \\(n\\) &amp; \\(m\\) elements there will be</p> <ul> <li>\\(\\min\\{n, m\\}\\) scalar subtractions (<code>isub</code>) &amp;</li> <li>\\(\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}\\) negations (<code>neg</code>).</li> </ul> See also <ul> <li>for difference on a single coefficient: <code>vecssubc</code></li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecssub(v, w):\n    r\"\"\"Return the difference.\n\n    $$\n        \\vec{v}-\\vec{w}\n    $$\n\n    Complexity\n    ----------\n    For two vectors with $n$ &amp; $m$ elements there will be\n\n    - $\\min\\{n, m\\}$ scalar subtractions (`isub`) &amp;\n    - $\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}$ negations (`neg`).\n\n    See also\n    --------\n    - for difference on a single coefficient: [`vecssubc`][vector.sparse.vector_space.vecssubc]\n    \"\"\"\n    r = dict(v)\n    for i, wi in w.items():\n        if i in r:\n            r[i] -= wi\n        else:\n            r[i] = -wi\n    return r\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsisub","title":"<code>vecsisub(v, w)</code>","text":"<p>Subtract.</p> \\[     \\vec{v} -= \\vec{w} \\] Complexity <p>For two vectors with \\(n\\) &amp; \\(m\\) elements there will be</p> <ul> <li>\\(\\min\\{n, m\\}\\) scalar subtractions (<code>isub</code>) &amp;</li> <li>\\(\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}\\) negations (<code>neg</code>).</li> </ul> See also <ul> <li>for difference on a single coefficient: <code>vecsisubc</code></li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsisub(v, w):\n    r\"\"\"Subtract.\n\n    $$\n        \\vec{v} -= \\vec{w}\n    $$\n\n    Complexity\n    ----------\n    For two vectors with $n$ &amp; $m$ elements there will be\n\n    - $\\min\\{n, m\\}$ scalar subtractions (`isub`) &amp;\n    - $\\begin{cases}m-n&amp;m\\ge n\\\\0&amp;m\\le n\\end{cases}$ negations (`neg`).\n\n    See also\n    --------\n    - for difference on a single coefficient: [`vecsisubc`][vector.sparse.vector_space.vecsisubc]\n    \"\"\"\n    for i, wi in w.items():\n        if i in v:\n            v[i] -= wi\n        else:\n            v[i] = -wi\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecssubc","title":"<code>vecssubc(v, c, i=0)</code>","text":"<p>Return the difference with a basis vector.</p> \\[     \\vec{v}-c\\vec{e}_i \\] Complexity <p>There will be</p> <ul> <li>one scalar subtraction (<code>isub</code>) if \\(i\\in\\vec{v}\\) or</li> <li>one scalar negation (<code>neg</code>) otherwise.</li> </ul> See also <ul> <li>for difference on more coefficients: <code>vecssub</code></li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecssubc(v, c, i=0):\n    r\"\"\"Return the difference with a basis vector.\n\n    $$\n        \\vec{v}-c\\vec{e}_i\n    $$\n\n    Complexity\n    ----------\n    There will be\n\n    - one scalar subtraction (`isub`) if $i\\in\\vec{v}$ or\n    - one scalar negation (`neg`) otherwise.\n\n    See also\n    --------\n    - for difference on more coefficients: [`vecssub`][vector.sparse.vector_space.vecssub]\n    \"\"\"\n    r = dict(v)\n    if i in r:\n        r[i] -= c\n    else:\n        r[i] = -c\n    return r\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsisubc","title":"<code>vecsisubc(v, c, i=0)</code>","text":"<p>Subtract a basis vector.</p> \\[     \\vec{v} -= c\\vec{e}_i \\] Complexity <p>There will be</p> <ul> <li>one scalar subtraction (<code>isub</code>) if \\(i\\in\\vec{v}\\) or</li> <li>one scalar negation (<code>neg</code>) otherwise.</li> </ul> See also <ul> <li>for difference on more coefficients: <code>vecsisub</code></li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsisubc(v, c, i=0):\n    r\"\"\"Subtract a basis vector.\n\n    $$\n        \\vec{v} -= c\\vec{e}_i\n    $$\n\n    Complexity\n    ----------\n    There will be\n\n    - one scalar subtraction (`isub`) if $i\\in\\vec{v}$ or\n    - one scalar negation (`neg`) otherwise.\n\n    See also\n    --------\n    - for difference on more coefficients: [`vecsisub`][vector.sparse.vector_space.vecsisub]\n    \"\"\"\n    if i in v:\n        v[i] -= c\n    else:\n        v[i] = -c\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsmul","title":"<code>vecsmul(v, a)</code>","text":"<p>Return the product.</p> \\[     \\vec{v}a \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar multiplications (<code>mul</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsmul(v, a):\n    r\"\"\"Return the product.\n\n    $$\n        \\vec{v}a\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar multiplications (`mul`).\n    \"\"\"\n    return {i:vi*a for i, vi in v.items()}\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsrmul","title":"<code>vecsrmul(a, v)</code>","text":"<p>Return the product.</p> \\[     a\\vec{v} \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar multiplications (<code>rmul</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsrmul(a, v):\n    r\"\"\"Return the product.\n\n    $$\n        a\\vec{v}\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar multiplications (`rmul`).\n    \"\"\"\n    return {i:a*vi for i, vi in v.items()}\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsimul","title":"<code>vecsimul(v, a)</code>","text":"<p>Multiply.</p> \\[     \\vec{v} \\cdot= a \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar multiplications (<code>imul</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsimul(v, a):\n    r\"\"\"Multiply.\n\n    $$\n        \\vec{v} \\cdot= a\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar multiplications (`imul`).\n    \"\"\"\n    for i in v:\n        v[i] *= a\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecstruediv","title":"<code>vecstruediv(v, a)</code>","text":"<p>Return the true quotient.</p> \\[     \\frac{\\vec{v}}{a} \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar true divisions (<code>truediv</code>).</li> </ul> Notes <p>Why called <code>truediv</code> instead of <code>div</code>?</p> <ul> <li><code>div</code> would be more appropriate for an absolutely clean mathematical implementation, that doesn't care about the language used. But the package might be used for pure integers/integer arithmetic, so both, <code>truediv</code> and <code>floordiv</code> operations have to be provided, and none should be privileged over the other by getting the universal <code>div</code> name.</li> <li><code>truediv</code>/<code>floordiv</code> is unambiguous, like Python <code>operator</code>s.</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecstruediv(v, a):\n    r\"\"\"Return the true quotient.\n\n    $$\n        \\frac{\\vec{v}}{a}\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar true divisions (`truediv`).\n\n    Notes\n    -----\n    Why called `truediv` instead of `div`?\n\n    - `div` would be more appropriate for an absolutely clean mathematical\n    implementation, that doesn't care about the language used. But the package\n    might be used for pure integers/integer arithmetic, so both, `truediv`\n    and `floordiv` operations have to be provided, and none should be\n    privileged over the other by getting the universal `div` name.\n    - `truediv`/`floordiv` is unambiguous, like Python `operator`s.\n    \"\"\"\n    return {i:vi/a for i, vi in v.items()}\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsitruediv","title":"<code>vecsitruediv(v, a)</code>","text":"<p>True divide.</p> \\[     \\vec{v} /= a \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar true divisions (<code>itruediv</code>).</li> </ul> Notes <p>Why called <code>truediv</code> instead of <code>div</code>?</p> <ul> <li><code>div</code> would be more appropriate for an absolutely clean mathematical implementation, that doesn't care about the language used. But the package might be used for pure integers/integer arithmetic, so both, <code>truediv</code> and <code>floordiv</code> operations have to be provided, and none should be privileged over the other by getting the universal <code>div</code> name.</li> <li><code>truediv</code>/<code>floordiv</code> is unambiguous, like Python <code>operator</code>s.</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsitruediv(v, a):\n    r\"\"\"True divide.\n\n    $$\n        \\vec{v} /= a\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar true divisions (`itruediv`).\n\n    Notes\n    -----\n    Why called `truediv` instead of `div`?\n\n    - `div` would be more appropriate for an absolutely clean mathematical\n    implementation, that doesn't care about the language used. But the package\n    might be used for pure integers/integer arithmetic, so both, `truediv`\n    and `floordiv` operations have to be provided, and none should be\n    privileged over the other by getting the universal `div` name.\n    - `truediv`/`floordiv` is unambiguous, like Python `operator`s.\n    \"\"\"\n    for i in v:\n        v[i] /= a\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsfloordiv","title":"<code>vecsfloordiv(v, a)</code>","text":"<p>Return the floor quotient.</p> \\[     \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar floor divisions (<code>floordiv</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsfloordiv(v, a):\n    r\"\"\"Return the floor quotient.\n\n    $$\n        \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar floor divisions (`floordiv`).\n    \"\"\"\n    return {i:vi//a for i, vi in v.items()}\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsifloordiv","title":"<code>vecsifloordiv(v, a)</code>","text":"<p>Floor divide.</p> \\[     \\vec{v} //= a \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar floor divisions (<code>ifloordiv</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsifloordiv(v, a):\n    r\"\"\"Floor divide.\n\n    $$\n        \\vec{v} //= a\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar floor divisions (`ifloordiv`).\n    \"\"\"\n    for i in v:\n        v[i] //= a\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsmod","title":"<code>vecsmod(v, a)</code>","text":"<p>Return the remainder.</p> \\[     \\vec{v} \\bmod a \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar modulos (<code>mod</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsmod(v, a):\n    r\"\"\"Return the remainder.\n\n    $$\n        \\vec{v} \\bmod a\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar modulos (`mod`).\n    \"\"\"\n    return {i:vi%a for i, vi in v.items()}\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsimod","title":"<code>vecsimod(v, a)</code>","text":"<p>Mod.</p> \\[     \\vec{v} \\%= a \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar modulos (<code>imod</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsimod(v, a):\n    r\"\"\"Mod.\n\n    $$\n        \\vec{v} \\%= a\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar modulos (`imod`).\n    \"\"\"\n    for i in v:\n        v[i] %= a\n    return v\n</code></pre>"},{"location":"sparse/#vector.sparse.vector_space.vecsdivmod","title":"<code>vecsdivmod(v, a)</code>","text":"<p>Return the floor quotient and remainder.</p> \\[     \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor, \\ \\left(\\vec{v} \\bmod a\\right) \\] Complexity <p>For a vector with \\(n\\) elements there will be</p> <ul> <li>\\(n\\) scalar divmods (<code>divmod</code>).</li> </ul> Source code in <code>vector\\sparse\\vector_space.py</code> <pre><code>def vecsdivmod(v, a):\n    r\"\"\"Return the floor quotient and remainder.\n\n    $$\n        \\left\\lfloor\\frac{\\vec{v}}{a}\\right\\rfloor, \\ \\left(\\vec{v} \\bmod a\\right)\n    $$\n\n    Complexity\n    ----------\n    For a vector with $n$ elements there will be\n\n    - $n$ scalar divmods (`divmod`).\n    \"\"\"\n    q, r = {}, {}\n    for i, vi in v.items():\n        q[i], r[i] = divmod(vi, a)\n    return q, r\n</code></pre>"},{"location":"sparse/#vector.sparse.elementwise","title":"<code>elementwise</code>","text":""},{"location":"sparse/#vector.sparse.elementwise.vecshadamard","title":"<code>vecshadamard(*vs)</code>","text":"<p>Return the elementwise product.</p> \\[     \\left((\\vec{v}_0)_i\\cdot(\\vec{v}_1)_i\\cdot\\cdots\\right)_i \\] Source code in <code>vector\\sparse\\elementwise.py</code> <pre><code>def vecshadamard(*vs):\n    r\"\"\"Return the elementwise product.\n\n    $$\n        \\left((\\vec{v}_0)_i\\cdot(\\vec{v}_1)_i\\cdot\\cdots\\right)_i\n    $$\n    \"\"\"\n    r = {}\n    if not vs:\n        return r\n    for k in set(vs[0].keys()).intersection(*(v.keys() for v in vs[1:])):\n        r[k] = prod_default((v[k] for v in vs), initial=MISSING, default=MISSING)\n    return r\n</code></pre>"},{"location":"sparse/#vector.sparse.elementwise.vecshadamardtruediv","title":"<code>vecshadamardtruediv(v, w)</code>","text":"<p>Return the elementwise true quotient.</p> \\[     \\left(\\frac{v_i}{w_i}\\right)_i \\] Source code in <code>vector\\sparse\\elementwise.py</code> <pre><code>def vecshadamardtruediv(v, w):\n    r\"\"\"Return the elementwise true quotient.\n\n    $$\n        \\left(\\frac{v_i}{w_i}\\right)_i\n    $$\n    \"\"\"\n    r = {}\n    for i, vi in v.items():\n        try:\n            wi = w[i]\n        except KeyError:\n            raise ZeroDivisionError\n        r[i] = vi / wi\n    return r\n</code></pre>"},{"location":"sparse/#vector.sparse.elementwise.vecshadamardfloordiv","title":"<code>vecshadamardfloordiv(v, w)</code>","text":"<p>Return the elementwise floor quotient.</p> \\[     \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i \\] Source code in <code>vector\\sparse\\elementwise.py</code> <pre><code>def vecshadamardfloordiv(v, w):\n    r\"\"\"Return the elementwise floor quotient.\n\n    $$\n        \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i\n    $$\n    \"\"\"\n    r = {}\n    for i, vi in v.items():\n        try:\n            wi = w[i]\n        except KeyError:\n            raise ZeroDivisionError\n        r[i] = vi // wi\n    return r\n</code></pre>"},{"location":"sparse/#vector.sparse.elementwise.vecshadamardmod","title":"<code>vecshadamardmod(v, w)</code>","text":"<p>Return the elementwise remainder.</p> \\[     \\left(v_i \\bmod w_i\\right)_i \\] Source code in <code>vector\\sparse\\elementwise.py</code> <pre><code>def vecshadamardmod(v, w):\n    r\"\"\"Return the elementwise remainder.\n\n    $$\n        \\left(v_i \\bmod w_i\\right)_i\n    $$\n    \"\"\"\n    r = {}\n    for i, vi in v.items():\n        try:\n            wi = w[i]\n        except KeyError:\n            raise ZeroDivisionError\n        r[i] = vi % wi\n    return r\n</code></pre>"},{"location":"sparse/#vector.sparse.elementwise.vecshadamarddivmod","title":"<code>vecshadamarddivmod(v, w)</code>","text":"<p>Return the elementwise floor quotient and remainder.</p> \\[     \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i, \\ \\left(v_i \\bmod w_i\\right)_i \\] Source code in <code>vector\\sparse\\elementwise.py</code> <pre><code>def vecshadamarddivmod(v, w):\n    r\"\"\"Return the elementwise floor quotient and remainder.\n\n    $$\n        \\left(\\left\\lfloor\\frac{v_i}{w_i}\\right\\rfloor\\right)_i, \\ \\left(v_i \\bmod w_i\\right)_i\n    $$\n    \"\"\"\n    q, r = {}, {}\n    for i, vi in v.items():\n        try:\n            wi = w[i]\n        except KeyError:\n            raise ZeroDivisionError\n        q[i], r[i] = divmod(vi, wi)\n    return q, r\n</code></pre>"},{"location":"sparse/#vector.sparse.elementwise.vecshadamardmin","title":"<code>vecshadamardmin(*vs, key=None)</code>","text":"<p>Return the elementwise minimum.</p> \\[     \\left(\\min((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\] Source code in <code>vector\\sparse\\elementwise.py</code> <pre><code>def vecshadamardmin(*vs, key=None):\n    r\"\"\"Return the elementwise minimum.\n\n    $$\n        \\left(\\min((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i\n    $$\n    \"\"\"\n    r = {}\n    if not vs:\n        return r\n    for k in set(vs[0].keys()).union(*(v.keys() for v in vs[1:])):\n        r[k] = min(v[k] for v in vs if k in v)\n    return r\n</code></pre>"},{"location":"sparse/#vector.sparse.elementwise.vecshadamardmax","title":"<code>vecshadamardmax(*vs, key=None)</code>","text":"<p>Return the elementwise maximum.</p> \\[     \\left(\\max((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i \\] Source code in <code>vector\\sparse\\elementwise.py</code> <pre><code>def vecshadamardmax(*vs, key=None):\n    r\"\"\"Return the elementwise maximum.\n\n    $$\n        \\left(\\max((\\vec{v}_0)_i,(\\vec{v}_1)_i,\\cdots)\\right)_i\n    $$\n    \"\"\"\n    r = {}\n    if not vs:\n        return r\n    for k in set(vs[0].keys()).union(*(v.keys() for v in vs[1:])):\n        r[k] = max(v[k] for v in vs if k in v)\n    return r\n</code></pre>"}]}